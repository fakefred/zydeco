ret { fn (x: Bool, y: Comp(Bool -> Ret(Bool))) -> !y x }
@@@ fn & app
let x = true,
    y = { ret false };
let f = { fn (b: Bool) -> ret b };
do  rx <- !f x,
    ry <- do y <- !y; !f x;
if x: ret rx else: ret ry
@@@ multiple bindings everywhere
let not = { fn (x: Bool) -> if x: ret false else: ret true },
    and = { fn (x: Bool, y: Bool) -> if x: ret y else: ret false },
    or = { fn (x: Bool, y: Bool) -> if x: ret true else: ret y };
do  a <- !and false true,
    b <- !or false true,
    c <- !not a;
!and c b
@@@ boolean operations
let nor = { fn (x: Bool, y: Bool) -> if x: if y: ret true else: ret false else: ret false };
do  a <- !nor false false;
!nor a a
@@@ boolean operations but better
data Boolean where
  | True()
  | False()
codata And where
  .then_(): Ret(Bool)
  .else_(): Ret(Bool)
let v = True();
match v
  | True -> (
    (comatch
      .then_ -> ret true
      .else_ -> ret false).then_()
  )
  | False -> ret false
@@@ data and codata syntax
do x <- (fn (x: Bool) -> ret 1) true;
do y <- (fn (x: Int) -> ret true) +123;
do z <- (fn (x: Int) -> ret true) -123;
ret x
@@@ basic number
data Nat where | Z() | S(Nat)
let add = {
  rec (add: Comp(Nat -> Nat -> Ret(Nat))) -> (
    fn (x: Nat, y: Nat) -> (
      match x
      | Z -> ret y
      | S(x) -> !add x S(y)
    )
  )
};
!add S(S(Z())) S(Z())
@@@ nat, our favorite
data Nat where | Z() | S(Nat)
let rec odd: Nat -> Ret(Bool) = (
  let even = {
    rec (even: Comp(Nat -> Ret(Bool))) -> (
      fn (x: Nat) -> (
        match x
        | Z -> ret true
        | S(x) -> !odd x
      )
    )
  };
  fn (x: Nat) -> (
    match x
    | Z -> ret false
    | S(x) -> !even x
  )
);
!odd S(S(S(Z())))
@@@ odd and even
data Nat where | Z() | S(Nat)
data FnPair where | FnPair(Comp(Nat -> Ret(Bool)), Comp(Nat -> Ret(Bool)))
let fp = {
  rec (_fp: Comp(Ret(FnPair))) -> (
    ret FnPair({
      do _fp <- !_fp;
      match _fp | FnPair(odd, even) -> (fn (x: Nat) -> (
        match x
        | Z -> ret false
        | S(x) -> !even x
      ))
    }, {
      do _fp <- !_fp;
      match _fp | FnPair(odd, even) -> (fn (x: Nat) -> (
        match x
        | Z -> ret true
        | S(x) -> !odd x
      ))
    })
  )
};
do odd <- (
  do fp <- !fp;
  match fp | FnPair(odd, even) -> ret odd
);
!odd S(S(S(Z())))
@@@ odd and even, but mutual recursion
