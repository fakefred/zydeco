use crate::parse::syntax::*;
grammar;


//* -------------------------------- TopLevel -------------------------------- */

pub Zydeco: Program<()> = <decls:Decl*> <comp:CompBox> => Program {
    decls,
    comp,
    ann: (),
};


//* ------------------------------ Declarations ------------------------------ */

Decl: Declare<()> = {
    "data" <name:TVar> "where" <ctors:CtorBranch*> => Declare::Data {
        name,
        ctors,
        ann: (),
    },
    "codata" <name:TVar> "where" <dtors:DtorBranch*> => Declare::Codata {
        name,
        dtors,
        ann: (),
    },
}

CtorBranch: (Ctor<()>, Vec<TValue<()>>) = {
    "|" <ctor:Ctor> "(" <args:Kleene<",", TVal>> ")" => {
        (ctor, args)
    }
}

DtorBranch: (Dtor<()>, Vec<TValue<()>>, TCompute<()>) = {
    "." <dtor:Dtor> "(" <args:Kleene<",", TVal>> ")" ":" <res:TComp> => {
        (dtor, args, res)
    }
}

//* ------------------------------- Expressions ------------------------------ */

CompBox: Box<Compute<()>> = {
    <CompHeadBox>,
    Boxed<Comp>,
}

Comp: Compute<()> = {
    "let" <bindings: Once<",", BindVal>> ";" <body:CompBox> => {
        *bindings.into_iter().rev().fold(body, |body, binding| Box::new(Compute::Let {
            binding, body, ann: ()
        }))
    },
    "rec" <bindings: Once<",", BindVal>> ";" <body:CompBox> => {
        *bindings.into_iter().rev().fold(body, |body, binding| Box::new(Compute::Rec {
            binding, body, ann: ()
        }))
    },
    "do" <bindings: Once<",", BindComp>> ";" <body:CompBox> => {
        *bindings.into_iter().rev().fold(body, |body, binding| Box::new(Compute::Do {
            binding, body, ann: ()
        }))
    },
    "fn" "(" <args:Once<",", FnArg>> ")" "->" <e:CompBox> =>
        *args.into_iter().rev().fold(e, |body, arg| Box::new(Compute::Lam{
            arg, body, ann: ()
        })),
    "if" <cond:ValBox> ":" <thn:CompBox> "else:" <els:CompBox> => Compute::If {
        cond, thn, els, ann: ()
    },
    "match" <scrut:ValBox> <cases:MatchBranch*> => Compute::Match {
        scrut, cases, ann: ()
    },
    "comatch" <cases:CoMatchBranch*> => Compute::CoMatch {
        cases, ann: ()
    },
    Arith
}

BindVal: (VVar<()>, Option<Box<TValue<()>>>, Box<Value<()>>) = {
    <Bind<"=", TValBox, ValBox>>
}

BindComp: (VVar<()>, Option<Box<TCompute<()>>>, Box<Compute<()>>) = {
    <Bind<"<-", TCompBox, CompBox>>
}

Bind<Delim, Typ, Def>: (VVar<()>, Option<Typ>, Def) = {
    <x:VVar> <ty:(":" <Typ>)?> <delim:Delim> <def:Def> => (x, ty, def),
}

FnArg: (VVar<()>, Option<Box<TValue<()>>>) = {
    <x:VVar> <t:(":" <TValBox>)?> => (x, t),
}

MatchBranch: (Ctor<()>, Vec<VVar<()>>, Box<Compute<()>>) = {
    "|" <c:Ctor> "(" <vs:VVar*> ")" "->" <e:CompAtomBox> => (c, vs, e),
    "|" <c:Ctor> "->" <e:CompAtomBox> => (c, vec!(), e),
}

CoMatchBranch: (Dtor<()>, Vec<VVar<()>>, Box<Compute<()>>) = {
    "." <d:Dtor> "(" <vs:VVar*> ")" "->" <e:CompAtomBox> => (d, vs, e),
    "." <d:Dtor> "->" <e:CompAtomBox> => (d, vec!(), e),
}

CompHeadBox: Box<Compute<()>> = {
    <CompAtomBox>,
    Boxed<CompHead>,
}

CompHead: Compute<()> = {
    <scrut:CompAtomBox> "." <dtor:Dtor> "(" <args:Kleene<",", Val>> ")" => Compute::CoApp {
        scrut, dtor, args, ann: ()
    },
}

CompAtomBox: Box<Compute<()>> = {
    Boxed<CompAtom>,
    "(" <CompBox> ")" => <>,
}

CompAtom: Compute<()> = {
    "!" <v:ValBox> => Compute::Force(v, ()),
    "ret" <v:ValBox> => Compute::Return(v, ()),
    <e:CompAtomBox> <v:ValBox> => Compute::App(e, v, ()),
}

//* ----------------------------- Arithmetic --------------------------------- */

Arith: Compute<()> = <l:ValBox> <op:ArithOp> <r:ValBox> => 
    Compute::App(Box::new(Compute::App(op, l, ())), r, ());

ArithOp: Box<Compute<()>> = <ArithOpName> => 
    Box::new(Compute::Force(Box::new(Value::Var(VVar::new(<>, ()), ())), ()));

ArithOpName: String = {
    "+" => "add".to_string(),
    "-" => "sub".to_string(),
    "*" => "mul".to_string(),
}

//* ---------------------------------- Value --------------------------------- */

ValBox: Box<Value<()>> = Boxed<Val>;

Val: Value<()> = {
    <x:VVar> => Value::Var(x, ()),
    "{" <e:CompBox> "}" => Value::Thunk(e, ()),
    <ctor:Ctor> "(" <vs:Kleene<",", <Val>>> ")" => Value::Ctor(ctor, vs, ()),
    <b:Bool> => Value::Bool(b, ()),
    <n:Int> => Value::Int(n,()),
    <s:String> => Value::String(s,()),
}


//* ---------------------------------- Types --------------------------------- */

TCompBox: Box<TCompute<()>> = Boxed<TComp>;

TComp: TCompute<()> = {
    <x:TVar> => TCompute::Var(x, ()),
    "Ret" "(" <t:TValBox> ")" => TCompute::Ret(t, ()),
    <tv:TValBox> "->" <tc:TCompBox> => TCompute::Lam(tv, tc, ()),
}

TValBox: Box<TValue<()>> = Boxed<TVal>;

pub TVal: TValue<()> = {
    <x:TVar> => TValue::Var(x, ()),
    "Comp" "(" <t:TCompBox> ")" => TValue::Comp(t, ()),
    "Bool" => TValue::Bool(()),
    "Int" => TValue::Int(()),
    "String" => TValue::String(()),
}


//* ------------------------------- Terminals ------------------------------ */

Ctor: Ctor<()> = <BigId> => Ctor::new(<>, ());
Dtor: Dtor<()> = <SmallId> => Dtor::new(<>, ());
TVar: TVar<()> = <BigId> => TVar::new(<>, ());
VVar: VVar<()> = <SmallId> => VVar::new(<>, ());

BigId: String = <r"[A-Z][a-zA-Z0-9_-]*"> => String::from(<>);
SmallId: String = <r"[a-z][a-zA-Z0-9_-]*"> => String::from(<>);

Bool: bool = {
    "true" => true,
    "false" => false,
}

Int: i64 = <s:r"[\+-]?[0-9]+"> => s.parse().unwrap();

String: String = <s:r#""[^"\\]*(?:\\.[^"\\]*)*""#> => 
    s[1..s.len()-1].to_string().replace("\\\"", "\"");


//* -------------------------------- Utilities ------------------------------- */

Kleene<Sym, T>: Vec<T> = {
    Sym? => vec![],
    Once<Sym, T>,
}
Once<Sym, T> : Vec<T> = {
    <e:T> <mut v:Rhs<Sym, T>*> <s:(<Sym>)?> => {
        v.insert(0, e);
        v
    }
}

Lhs<L, R> : L = {
    <l:L> <r:R> => l,
}
Rhs<L, R> : R = {
    <l:L> <r:R> => r,
}

Boxed<T> : Box<T> = {
    T => Box::new(<>)
}
