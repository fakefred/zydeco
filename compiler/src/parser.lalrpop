// use std::str::FromStr;
use crate::syntax::{TValue, TCompute, Value, Compute};

grammar;

pub Computation: Box<Compute<()>> = <CompBox>;

CompBox: Box<Compute<()>> = Boxed<Comp>;

Comp: Compute<()> = {
    <CompAtom>,
    "let" <bindings: CommaOnce<BindVal>> ";" <body:CompBox> => {
        *bindings.into_iter().rev().fold(body, |body, binding| Box::new(Compute::Let {
            binding, body, ann: ()
        }))
    },
    "do" <bindings: CommaOnce<BindComp>> ";" <body:CompBox> => {
        *bindings.into_iter().rev().fold(body, |body, binding| Box::new(Compute::Do {
            binding, body, ann: ()
        }))
    },
    "ret" <v:ValBox> => Compute::Return(v, ()),
    "if" <cond:ValBox> "{" <thn:CompBox> "}" "else" "{" <els:CompBox> "}" => Compute::If {
        cond, thn, els, ann: ()
    },
}

CompAtomBox: Box<Compute<()>> = {
    Boxed<CompAtom>,
    "(" <CompBox> ")" => <>,
}

CompAtom: Compute<()> = {
    "!" <v:ValBox> => Compute::Force(v, ()),
    "fn" "(" <args:CommaOnce<Arg>> ")" "{" <e:CompBox> "}" =>
    *args.into_iter().rev().fold(e, |body, arg| Box::new(Compute::Lam{
        arg, body, ann: ()
        })),
    <e:CompAtomBox> <v:ValBox> => Compute::App(e, v, ()),
}

BindVal: (String, Box<Value<()>>) = {
    <x:Id> "=" <v:ValBox> => (x, v),
}

BindComp: (String, Box<Compute<()>>) = {
    <x:Id> "<-" <c:CompBox> => (x, c),
}

Arg: (String, Box<TValue<()>>) = {
    <x:Id> ":" <t:TValBox> => (x, t),
}

ValBox: Box<Value<()>> = Boxed<Val>;

Val: Value<()> = {
    <x:Id> => Value::Var(x, ()),
    "{" <e:CompBox> "}" => Value::Thunk(e, ()),
    <b:Bool> => Value::Bool(b, ()),
}

TCompBox: Box<TCompute<()>> = Boxed<TComp>;

TComp: TCompute<()> = {
    "Ret" "(" <t:TValBox> ")" => TCompute::Ret(t, ()),
    <tv:TValBox> "->" <tc:TCompBox> => TCompute::Lam(tv, tc, ()),
}

TValBox: Box<TValue<()>> = Boxed<TVal>;

TVal: TValue<()> = {
    "Comp" "(" <t:TCompBox> ")" => TValue::Comp(t, ()),
    "Bool" => TValue::Bool(()),
}

Boxed<T> : Box<T> = {
    T => Box::new(<>)
}

Once<Sym, T> : Vec<T> = {
    <e:T> <mut v:(Rhs<Sym, T>)*> <s:(<Sym>)?> => {
        v.insert(0, e);
        v
    }
}

Rhs<L, R> : R = {
    <l:L> <r:R> => r,
}

CommaOnce<T> : Vec<T> = Once<Comma, T>;

Comma: () = ",";
SemiColon: () = ";";

Id: String = <s:r"[a-zA-Z][a-zA-Z0-9_-]*"> => String::from(s);

Bool: bool = {
    "true" => true,
    "false" => false,
}
