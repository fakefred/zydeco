data SynVal where
  | Var(String)
  | True()
  | False()
  | ThunkV(SynComp)

data SynComp where
  | If(SynVal, SynComp, SynComp)
  | Force(SynVal)
  | Lam(String, SynComp)
  | App(SynComp, SynVal)
  | Return(SynVal)
  | Bind(SynComp, String, SynComp)

data Env where
  | Empty()
  | Cons(String, SemVal, Env)

data SemVal where
  | True'()
  | False'()
  | ThunkV'(Comp(SemComp))

data OptionSemVal where
  | Ok(SemVal)
  | Err()

codata SemComp where
  .app(SemVal) : SemComp
  .bind()      : Ret(OptionSemVal)

codata Interpreter where
  .valu(SynVal, Env): Ret(OptionSemVal)
  .comp(SynComp, Env): SemComp

let rec lookup: String -> Env -> Ret(OptionSemVal) =
  fn (x : String, g : Env) ->
    match g
    | Empty() -> ret Err()
    | Cons(y,v,g) -> (
      do b <- ! str_eq x y;
      if b: ret Ok(v)
      else: ! lookup x g
    );

let rec error: SemComp = (
  comatch
    | .app(_) -> ! error
    | .bind() -> ret Err()
);

let rec interp: Interpreter =
  comatch
    | .valu(v, g) -> (
      match v
      | Var(x) -> ! lookup x g
      | True() -> ret Ok(True'())
      | False() -> ret Ok(False'())
      | ThunkV(m) -> ret Ok(ThunkV'({ ! interp .comp(m, g) }))
    )
    | .comp(m, g) -> (
      match m
      | If(cond, mt, mf) -> (
        match cond
        | True() -> ! interp .comp(mt, g)
        | False() -> ! interp .comp(mf, g)
      )
      | Force(syn_val) -> (
        do v? <- ! interp .valu(syn_val, g);
        match v?
        | Ok(v) -> (
          match v
          | ThunkV'(t) -> ! t
          | True'() -> ! error
          | False'() -> ! error
        )
        | Err() -> ! error
      )
      | Return(syn_val) -> (
        do v <- ! interp .valu(syn_val, g);
        comatch
          | .bind() -> ret v
          | .app(_) -> ! error
      )
      | Bind(m, x, k) -> (
        do v? <- ! interp .comp(m, g) .bind();
        match v?
        | Ok(v) -> ! interp .comp(k, Cons(x, v, g))
        | Err() -> ! error
      )
      | Lam(x, m) -> (
        comatch
          | .app(v) -> (! interp .comp(m, Cons(x, v, g)))
          | .bind() -> ret Err()
      )
      | App(m, v) -> (
        do v? <- ! interp .valu(v, g);
        match v?
        | Ok(v) -> ! interp .comp(m, g) .app(v)
        | Err() -> ! error
      )
    );

! interp .comp(App(Lam("x", Return(Var("x"))), False()), Empty()) .bind()