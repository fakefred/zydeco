data Nat where | Z() | S(Nat)
let zero = Z();
let suc = {
  fn (x: Nat) -> ret S(x)
};
let ifz = {
  fn (z: Bool, pred: Comp(Nat -> Ret(Bool)), x: Nat) -> (
    match x
    | Z() -> ret z
    | S(x) -> !pred x
  )
};
do one <- !suc zero,
   two <- !suc one;
let ifz = {
  fn (x: Nat) -> (
    !ifz false { fn (_: Nat) -> ret false } x
  )
};
do two' <- !ifz two;
do one' <- !ifz one;
do zero' <- !ifz zero;
if two': if one': if zero': ret true
else: ret false else: ret false else: ret false
@@@ nat, our favorite

data Nat where | Z() | S(Nat)
let add = {
  rec (add: Comp(Nat -> Nat -> Ret(Nat))) -> (
    fn (x: Nat, y: Nat) -> (
      match x
      | Z -> ret y
      | S(x) -> !add x S(y)
    )
  )
};
let rec add': Nat -> Nat -> Ret(Nat) = (
  fn (x: Nat, y: Nat) -> (
    match x
    | Z -> ret y
    | S(x) -> !add x S(y)
  )
);
do x <- !add S(S(Z())) S(Z());
!add' x S(S(S(Z())))
@@@ add, adder

data Nat where | Z() | S(Nat)
let rec odd: Nat -> Ret(Bool) = (
  let even = {
    rec (even: Comp(Nat -> Ret(Bool))) -> (
      fn (x: Nat) -> (
        match x
        | Z -> ret true
        | S(x) -> !odd x
      )
    )
  };
  fn (x: Nat) -> (
    match x
    | Z -> ret false
    | S(x) -> !even x
  )
);
!odd S(S(S(Z())))
@@@ odd and even

data Nat where | Z() | S(Nat)
data OddEven where | OddEven(Comp(Nat -> Ret(Bool)), Comp(Nat -> Ret(Bool)))
let rec fp: Ret(OddEven) = (
  ret OddEven({
    do fp <- !fp;
    match fp | OddEven(odd, even) -> (fn (x: Nat) -> (
      match x
      | Z -> ret false
      | S(x) -> !even x
    ))
  }, {
    do fp <- !fp;
    match fp | OddEven(odd, even) -> (fn (x: Nat) -> (
      match x
      | Z -> ret true
      | S(x) -> !odd x
    ))
  })
);
do odd <- (
  do fp <- !fp;
  match fp | OddEven(odd, even) -> ret { !odd }
);
!odd S(S(S(Z())))
@@@ odd and even, but mutual recursion

