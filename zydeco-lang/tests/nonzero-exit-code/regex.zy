data Syn where
  | Str(String)
  | Concat(Syn, Syn)
  | Kleene(Syn)
  | Choose(Syn, Syn)
end

data Option (A : VType) where
  | Some(A)
  | None()
end

codata Matcher where
  | .str(String): F(Option String)
  | .concat(Syn, Syn): F(Option String)
  | .kleene(Syn): F(Option String)
  | .choose(Syn, Syn): F(Option String)
  | .bind(Syn): F(Option String)
end

codata Regex where
  | .run(String): Matcher
end

let str_chop_hd : U(String -> Int -> F(String)) = { fn (s: String) (i: Int) -> (
  do l <- ! str_length s;
  let rec str_collect : String -> Int -> String -> Ret(String) = fn (s: String) (i: Int) (r: String) -> (
    do continue? <- ! int_lt i l;
    match continue?
    | False() -> ret r
    | True() -> (
      do tl <- ! str_index s i;
      do tl <- ! char_to_str tl;
      do r <- ! str_append r tl;
      do i+1 <- ! add i 1;
      ! str_collect s i+1 r)
    end
  );
  ! str_collect s i ""
)};

let fn str_eq_at (a: String) (b: String) (i: Int): F Bool =
  do ai <- ! str_index a i;
  do bi <- ! str_index b i;
  ! char_eq ai bi
in

let str_match : U(String -> String -> F(Option String)) = {
  let rec str_match : Int -> String -> String -> F(Option String) =
    fn (i: Int) (s: String) (p: String) -> (
      do s_len <- ! str_length s;
      do p_len <- ! str_length p;
      do i_lt_s <- ! int_lt i s_len;
      do i_lt_p <- ! int_lt i p_len;
      match i_lt_p
      | False() -> (
        do s' <- ! str_chop_hd s i;
        ret Some(s'))
      | True() -> (
        match i_lt_s
        | False() -> ret None()
        | True() -> (
          do eq? <- ! str_eq_at s p i;
          match eq?
          | False() -> ret None()
          | True() -> (
            do i+1 <- ! add i 1;
            ! str_match i+1 s p)
          end)
        end)
      end
    );
  ! str_match 0
};

let rec regex : Regex = ( comatch | .run(s) -> (
  comatch
  | .str(p) -> ! str_match s p
  | .concat(sy1, sy2) -> (
    do s? <- ! regex .run(s) .bind(sy1);
    match s?
    | None() -> ret None()
    | Some(s) -> (
      ! regex .run(s) .bind(sy2))
    end)
  | .kleene(sy) -> (
    do s? <- ! regex .run(s) .bind(sy);
    match s?
    | None() -> ret Some(s)
    | Some(s) -> ! regex .run(s) .kleene(sy)
    end)
  | .choose(sy1, sy2) -> (
    do s? <- ! regex .run(s) .bind(sy1);
    match s?
    | Some(s) -> ret Some(s)
    | None() -> ! regex .run(s) .bind(sy2)
    end)
  | .bind(sy) -> (
    match sy
    | Str(p) -> ! regex .run(s) .str(p)
    | Concat(sy1, sy2) -> ! regex .run(s) .concat(sy1, sy2)
    | Kleene(sy) -> ! regex .run(s) .kleene(sy)
    | Choose(sy1, sy2) -> ! regex .run(s) .choose(sy1, sy2)
    end)
  end)
end);

let fn demo (syn: Syn) (str: String) (kont: U(OS)): OS =
  do res <- ! regex .run(str) .bind(syn);
  match res
  | Some(s) -> (
    ! write_line s kont)
  | None() -> ! exit 1
  end
in

! demo (Concat(Kleene(Str("p")), Concat(Kleene(Str("q")), Choose(Str("xos"), Str("sox"))))) "pppqqqsox\\^o^/" {
! exit 0
}
