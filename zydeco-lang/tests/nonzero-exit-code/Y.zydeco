codata Y where
  | .y(U(Y)): Int -> F(Int)
end
# \f. (\x. f (x x)) (\x. f (x x))
# The famous Y combinator in call-by-name sense actually works
# under call-by-push-value - thanks to thunks, we are able to
# preserve the intention of lazy evaluation in `x` above.

let fn y (f: U(U(Int -> F(Int)) -> Int -> F(Int))): F(U(Int -> F(Int))) =
  ret {
    (comatch | .y(x) -> ! f { ! x .y(x) } end :: Y)
    .y({ (comatch | .y(x) -> ! f { ! x .y(x) } end :: Y) })
  }
in

# good old factorial
let fn fact (f: U(Int -> F Int)) (n: Int): F Int =
  do is_zero <- ! int_eq n 0;
  match is_zero
  | True() -> ret 1
  | False() -> (
    do rest <-
      do n-1 <- !sub n 1;
      ! f n-1;
    ! mul n rest
  )
  end
in

do fact <- ! y fact;

# tests
let fn demo (input: Int) (expected: Int) (t: Thunk(OS)): OS =
  do x <- ! fact input;
  do correct <- ! int_eq x expected;
  match correct
  | True() -> ! t
  | False() -> (
    do input <- ! int_to_str input;
    do expected <- ! int_to_str expected;
    do got <- ! int_to_str x;
    do msg <- ! str_append "f " input;
    do msg <- ! str_append msg " = ";
    do msg <- ! str_append msg expected;
    do msg <- ! str_append msg ", got ";
    do msg <- ! str_append msg got;
    ! write_line msg { ! exit 1 }
  )
  end
in

! demo 5 120 {
! demo 10 3628800 {
! exit 0 }}
