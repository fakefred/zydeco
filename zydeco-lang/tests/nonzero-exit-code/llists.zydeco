data LList (A : VType) where
  | Nil()
  | Cons(A, U(F(LList A)))
end

codata IOS where
  | .i(Int): OS
end

## LList is actually coinductive type

# let rec loop : F(LList Int) = (
#   ret Cons(0, loop)
# );

## foldr and an example of summing up the list and exiting with the sum

# let rec foldr : U(F(LList Int)) -> U(Int -> U(IOS) -> IOS) -> U(IOS) -> IOS = (
#   fn (ll: U(F(LList Int)), f: U(Int -> U(IOS) -> IOS), b: U(IOS)) ->
#     do llv <- ! ll;
#     match llv
#     | Nil() -> ! b
#     | Cons(a, ll) -> ! f a { ! foldr ll f b }
# );

# ! foldr
# { ret Cons(1, { ret Cons(-1, { ret Nil() }) }) }
# { fn (a: Int, b: U(IOS)) -> comatch | .i(x) -> (
#   do x <- ! add a x;
#   ! b .i(x))
# }
# { comatch | .i(x) -> ! exit x }
# .i(0)

## Since it's coinductive, can we write iota?

let rec fn iota (i : Int) : F(LList Int) = (
  do i+1 <- ! add i 1;
  ret Cons(i, { ! iota i+1 })
);

let rec fn foldr (ll : U(F(LList Int))) (f : U(Int -> U(OS) -> OS)) (b : U(OS)) : OS =
  do llv <- ! ll;
  match llv
  | Nil() -> ! b
  | Cons(a, ll) -> ! f a { ! foldr ll f b }
  end
in

let loopy = {
  ! foldr
  { ! iota 0 }
  { fn (x: Int) (b: U(OS)) ->
    do next? <- ! int_lt x 10;
    match next?
    | True() -> ! write_int_line x b
    | False() -> ! exit 0
    end
  }
  { ! panic "unreachable" }
};

! loopy