# zydeco std


module Builtin where
  ## the Thunk and Ret types

  pub extern data Thunk (B : CType) end
  pub extern codata Ret (A : VType) end
  pub alias Comp (B : CType) = Thunk B end
  pub alias U (B : CType) = Thunk B end
  pub alias F (A : VType) = Ret A end

  ## the Fn type

  pub codata Fn (A: VType) (B: CType) where
    | .arg(A) : B
  end
  ### Functions are syntax sugars around this internal type definition.
end


module Std where
  ## identities

  def id : Thunk(forall (A : VType) . A -> Ret A) = {
    fn A x -> ret x
  } end

  def id~ : Thunk(forall (B : CType) . Thunk B -> B) = {
    fn B x -> ! x
  } end


  ## 1 and 2 types

  pub data Unit where
    | Unit()
  end

  pub data Bool where
    | True()
    | False()
  end

  pub def true : Bool = True() end
  pub def false : Bool = False() end

  pub def not : Thunk(Bool -> Ret(Bool)) = {
    fn (x) ->
      match x
      | True() -> ret false
      | False() -> ret true
      end
  } end

  # lazy not
  pub def not~ : Thunk(Thunk(Ret(Bool)) -> Ret(Bool)) = {
    fn t~ ->
      do x <- ! t~;
      match x
      | True() -> ret false
      | False() -> ret true
      end
  } end

  pub def and : Thunk(Bool -> Bool -> Ret(Bool)) = {
    fn x y ->
      match x
      | True() -> ret y
      | False() -> ret false
      end
  } end

  # Lazy, short-circuiting (left to right) and
  pub def and~ : Thunk(Thunk(Ret(Bool)) -> Thunk(Ret(Bool)) -> Ret(Bool)) = {
    fn b1~ b2~ ->
    do b1 <- ! b1~;
    match b1
    | True() -> ! b2~
    | False() -> ret false
    end
  } end

  pub def or : Thunk(Bool -> Bool -> Ret(Bool)) = {
    fn x y ->
      match x
      | True() -> ret true
      | False() -> ret y
      end
  } end

  # Lazy, short-circuiting (left to right) or
  pub def or~ : Thunk(Thunk(Ret(Bool)) -> Thunk(Ret(Bool)) -> Ret(Bool)) = {
    fn b1~ b2~ ->
    do b1 <- ! b1~;
    match b1
    | True() -> ret true
    | False() -> ! b2~
    end
  } end

  pub def nand : Thunk(Bool -> Bool -> Ret(Bool)) = {
    fn x y ->
      do a <- ! and x y;
      ! not a
  } end

  pub def nor : Thunk(Bool -> Bool -> Ret(Bool)) = {
    fn x y ->
      do a <- ! or x y;
      ! not a
  } end

  pub def bool_eq : Thunk(Bool -> Bool -> Ret(Bool)) = {
    fn b b' ->
      match b
      | True() -> ret b'
      | False() -> ! not b'
      end
  } end

  pub def if : Thunk(forall (B : CType) . Bool -> Thunk B -> Thunk B -> B) = {
    fn B b thn els ->
      match b
      | True()  -> ! thn
      | False() -> ! els
      end
  } end
  pub def ifc : Thunk(forall (B : CType) . Thunk(Ret Bool) -> Thunk B -> Thunk B -> B) = {
    fn B b thn els ->
      do b <- ! b;
      ! if @(B) b thn els
  } end


  ## nat

  data Nat where
    | Z()
    | S(Nat)
  end

  def rec fn iter (A : VType) (n : Nat) (x : A) (f : U (A -> F A)) : F A =
    match n
    | Z() -> ret x
    | S(n') ->
      do x' <- ! iter @(A) n' x f;
      ! f x'
    end
  end


  ## the List and LList types

  pub data List (A : VType) where
    | Nil()
    | Cons(A, List A)
  end

  pub def rec foldl : forall (A : VType) (R : VType) . List A -> Thunk(A -> R -> Ret(R)) -> R -> Ret(R) =
    fn A R l step s ->
      match l
      | Nil() -> ret s
      | Cons(x, xs) -> (
        do s' <- ! step x s;
        ! foldl @(A) @(R) xs step s'
      )
      end
  end

  pub data LListV (A : VType) (B : CType) where
    | Nil()
    | Cons(A, Thunk(B))
  end

  pub codata LList (A : VType) where
    | .run(): Ret (LListV A (LList A))
  end
end


module Std where
  ## arithmetic operations

  ### we support the constructors externally because
  ### the parsers of their constructors are customized
  ### so the type is registered as a data type but the constructors
  ### are not implemented as internal constructors
  pub extern data Int end

  pub extern def add : Thunk(Int -> Int -> Ret Int) end
  pub extern def sub : Thunk(Int -> Int -> Ret Int) end
  pub extern def mul : Thunk(Int -> Int -> Ret Int) end
  pub extern def div : Thunk(Int -> Int -> Ret Int) end
  pub extern def mod : Thunk(Int -> Int -> Ret Int) end

  pub extern def int_eq : Thunk(Int -> Int -> Ret Bool) end
  pub extern def int_lt : Thunk(Int -> Int -> Ret Bool) end
  pub extern def int_gt : Thunk(Int -> Int -> Ret Bool) end
end


module Std where
  ## string operations

  pub extern data Char end
  pub extern data String end
  ### we support the constructors externally

  pub extern def str_length : Thunk(String -> Ret Int) end
  pub extern def str_append : Thunk(String -> String -> Ret String) end
  pub extern def str_eq : Thunk(String -> String -> Ret Bool) end
  pub extern def str_index : Thunk(String -> Int -> Ret Char) end

  pub def char_eq: Thunk(Char -> Char -> Ret Bool) = {
    fn (c: Char) (c': Char) ->
      do c <- ! char_to_str c;
      do c' <- ! char_to_str c';
      ! str_eq c c'
  } end


  ## conversions

  pub def unit_to_str : Thunk(Unit -> Ret String) = {
    fn (_u : Unit) -> ret "()"
  } end
  pub def bool_to_str : Thunk(Bool -> Ret String) = {
    fn (b : Bool) ->
      match b
      | True() -> ret "True"
      | False() -> ret "False"
      end
  } end

  pub extern def int_to_str : Thunk(Int -> Ret(String)) end
  pub extern def char_to_str : Thunk(Char -> Ret(String)) end
  pub extern def char_to_int : Thunk(Char -> Ret(Int)) end
  pub extern def str_to_int : Thunk(String -> Ret(Int)) end
end


module Std where
  ## some OS operations

  pub extern codata OS end
  pub extern def write_str : Thunk(String -> Thunk(OS) -> OS) end
  pub extern def read_line : Thunk(Thunk(String -> OS) -> OS) end
  pub extern def exit : Thunk(Int -> OS) end
  pub extern def arg_list : Thunk(Thunk(List String -> OS) -> OS) end

  pub def write_line : Thunk(String -> Thunk(OS) -> OS) = {
    fn (s: String) (k: Thunk(OS)) ->
      do s <- ! str_append s "\n";
      ! write_str s k
  } end

  pub def write_int : Thunk(Int -> Thunk(OS) -> OS) = {
    fn (i: Int) (k: Thunk(OS)) ->
      do s <- ! int_to_str i;
      ! write_str s k
  } end

  pub def write_int_line : Thunk(Int -> Thunk(OS) -> OS) = {
    fn (i: Int) (k: Thunk(OS)) ->
      do s <- ! int_to_str i;
      ! write_line s k
  } end

  pub def panic : Thunk(String -> OS) = {
    fn (msg: String) ->
      do msg <- ! str_append "Program panicked with message: " msg;
      ! write_line msg { ! exit 1 }
  } end
end