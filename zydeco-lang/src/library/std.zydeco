# zydeco std


## Thunk and Ret types
pub extern data Thunk_U (B : CType) where
end
pub extern codata Ret_F (A : VType) where
end


## 1 and 2 types

pub data Unit where
  | Unit()
end

pub data Bool where
  | True()
  | False()
end

pub define true : Bool = True();
pub define false : Bool = False();

pub define not : Thunk(Bool -> Ret(Bool)) = {
  fn (x) ->
    match x
    | True() -> ret false
    | False() -> ret true
    end
};

# function
pub codata Fn (A: VType) (B: CType) where
  | .arg(A) : B
end

# lazy not
pub define not~ : Thunk(Thunk(Ret(Bool)) -> Ret(Bool)) = {
  fn t~ ->
    do x <- ! t~;
    match x
    | True() -> ret false
    | False() -> ret true
    end
};

pub define and : Thunk(Bool -> Bool -> Ret(Bool)) = {
  fn x y ->
    match x
    | True() -> ret y
    | False() -> ret false
    end
};

# Lazy, short-circuiting (left to right) and
# Can we come up with a better naming convention? Maybe and~ is more suggestive?
# ~~(not accepted by parser currently)~~ accepted now
pub define and~ : Thunk(Thunk(Ret(Bool)) -> Thunk(Ret(Bool)) -> Ret(Bool)) = {
  fn b1~ b2~ ->
  do b1 <- ! b1~;
  match b1
  | True() -> ! b2~
  | False() -> ret false
  end
};

pub define or : Thunk(Bool -> Bool -> Ret(Bool)) = {
  fn x y ->
    match x
    | True() -> ret true
    | False() -> ret y
    end
};

# Lazy, short-circuiting (left to right) or
pub define or~ : Thunk(Thunk(Ret(Bool)) -> Thunk(Ret(Bool)) -> Ret(Bool)) = {
  fn b1~ b2~ ->
  do b1 <- ! b1~;
  match b1
  | True() -> ret true
  | False() -> ! b2~
  end
};

pub define nand : Thunk(Bool -> Bool -> Ret(Bool)) = {
  fn x y ->
    do a <- ! and x y;
    ! not a
};

pub define nor : Thunk(Bool -> Bool -> Ret(Bool)) = {
  fn x y ->
    do a <- ! or x y;
    ! not a
};

pub define bool_eq : Thunk(Bool -> Bool -> Ret(Bool)) = {
  fn b b' ->
    match b
    | True() -> ret b'
    | False() -> ! not b'
    end
};

# pub define ifc : Thunk(Thunk(Ret(Bool)) -> Thunk(b) -> Thunk(b) -> b) = {
#  fn b thn els ->
#    match b
#    | True()  -> ! thn
#    | False() -> ! els
# };
# pub define if : Thunk(Bool -> Thunk(a) -> Thunk(a) -> Ret(a)) = {
#   fn (b : Bool, t : Thunk(a), f : Thunk(a)) ->
#     match b
#     | True() -> ! t
#     | False() -> ! f
# };
### Waiting for polymorphism

### Moving the built-in function to internal


## arithmetic operations

pub extern data Int where
end
### we support the constructors externally because
### the parsers of their constructors are customized
### so the type is registered as a data type but the constructors
### are not implemented as internal constructors

pub extern define add : Thunk(Int -> Int -> Ret Int);
pub extern define sub : Thunk(Int -> Int -> Ret Int);
pub extern define mul : Thunk(Int -> Int -> Ret Int);
pub extern define div : Thunk(Int -> Int -> Ret Int);
pub extern define mod : Thunk(Int -> Int -> Ret Int);

pub extern define int_eq : Thunk(Int -> Int -> Ret Bool);
pub extern define int_lt : Thunk(Int -> Int -> Ret Bool);
pub extern define int_gt : Thunk(Int -> Int -> Ret Bool);


## string operations

pub extern data Char where
end
pub extern data String where
end
### we support the constructors externally

pub extern define str_length : Thunk(String -> Ret Int);
pub extern define str_append : Thunk(String -> String -> Ret String);
pub extern define str_eq : Thunk(String -> String -> Ret Bool);
pub extern define str_index : Thunk(String -> Int -> Ret Char);

pub define char_eq: Thunk(Char -> Char -> Ret Bool) = {
  fn (c: Char) (c': Char) ->
    do c <- ! char_to_str c;
    do c' <- ! char_to_str c';
    ! str_eq c c'
};


## conversions

pub define unit_to_str : Thunk(Unit -> Ret String) = {
  fn (_u : Unit) -> ret "()"
};
pub define bool_to_str : Thunk(Bool -> Ret String) = {
  fn (b : Bool) ->
    match b
    | True() -> ret "True"
    | False() -> ret "False"
    end
};

pub extern define int_to_str : Thunk(Int -> Ret(String));
pub extern define char_to_str : Thunk(Char -> Ret(String));
pub extern define char_to_int : Thunk(Char -> Ret(Int));
pub extern define str_to_int : Thunk(String -> Ret(Int));


## List and LList

pub data List (A : VType) where
| Nil()
| Cons(A, List A)
end

pub data LListV (A : VType) (B : CType) where
  | Nil()
  | Cons(A, Thunk(B))
end

pub codata LList (A : VType) where
  | .run(): Ret (LListV A (LList A))
end


## OS operations

pub extern codata OS where
end
pub extern define write_str : Thunk(String -> Thunk(OS) -> OS);
pub extern define read_line : Thunk(Thunk(String -> OS) -> OS);
pub extern define exit : Thunk(Int -> OS);
pub extern define arg_list : Thunk(Thunk(List String -> OS) -> OS);

pub define write_line : Thunk(String -> Thunk(OS) -> OS) = {
  fn (s: String) (k: Thunk(OS)) ->
    do s <- ! str_append s "\n";
    ! write_str s k
};

pub define write_int : Thunk(Int -> Thunk(OS) -> OS) = {
  fn (i: Int) (k: Thunk(OS)) ->
    do s <- ! int_to_str i;
    ! write_str s k
};

pub define write_int_line : Thunk(Int -> Thunk(OS) -> OS) = {
  fn (i: Int) (k: Thunk(OS)) ->
    do s <- ! int_to_str i;
    ! write_line s k
};

pub define panic : Thunk(String -> OS) = {
  fn (msg: String) ->
    do msg <- ! str_append "Program panicked with message: " msg;
    ! write_line msg { ! exit 1 }
};
