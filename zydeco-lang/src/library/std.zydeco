# zydeco std


## the Thunk and Ret types

pub extern data Thunk (B : CType) end
pub extern codata Ret (A : VType) end
pub alias Comp (B : CType) = Thunk B end
pub alias U (B : CType) = Thunk B end
pub alias F (A : VType) = Ret A end


## the Fn type

pub codata Fn (A: VType) (B: CType) where
  | .arg(A) : B
end
### Functions are syntax sugars around this internal type definition.


## identities

def id : Thunk(forall (A : VType) . A -> Ret A) = {
    fn A x -> ret x
} end

def id~ : Thunk(forall (B : CType) . Thunk B -> B) = {
    fn B x -> ! x
} end


## 1 and 2 types

pub data Unit where
  | Unit()
end

pub data Bool where
  | True()
  | False()
end

pub def true : Bool = True();
pub def false : Bool = False();

pub def not : Thunk(Bool -> Ret(Bool)) = {
  fn (x) ->
    match x
    | True() -> ret false
    | False() -> ret true
    end
};

# lazy not
pub def not~ : Thunk(Thunk(Ret(Bool)) -> Ret(Bool)) = {
  fn t~ ->
    do x <- ! t~;
    match x
    | True() -> ret false
    | False() -> ret true
    end
};

pub def and : Thunk(Bool -> Bool -> Ret(Bool)) = {
  fn x y ->
    match x
    | True() -> ret y
    | False() -> ret false
    end
};

# Lazy, short-circuiting (left to right) and
pub def and~ : Thunk(Thunk(Ret(Bool)) -> Thunk(Ret(Bool)) -> Ret(Bool)) = {
  fn b1~ b2~ ->
  do b1 <- ! b1~;
  match b1
  | True() -> ! b2~
  | False() -> ret false
  end
};

pub def or : Thunk(Bool -> Bool -> Ret(Bool)) = {
  fn x y ->
    match x
    | True() -> ret true
    | False() -> ret y
    end
};

# Lazy, short-circuiting (left to right) or
pub def or~ : Thunk(Thunk(Ret(Bool)) -> Thunk(Ret(Bool)) -> Ret(Bool)) = {
  fn b1~ b2~ ->
  do b1 <- ! b1~;
  match b1
  | True() -> ret true
  | False() -> ! b2~
  end
};

pub def nand : Thunk(Bool -> Bool -> Ret(Bool)) = {
  fn x y ->
    do a <- ! and x y;
    ! not a
};

pub def nor : Thunk(Bool -> Bool -> Ret(Bool)) = {
  fn x y ->
    do a <- ! or x y;
    ! not a
};

pub def bool_eq : Thunk(Bool -> Bool -> Ret(Bool)) = {
  fn b b' ->
    match b
    | True() -> ret b'
    | False() -> ! not b'
    end
};

pub def if : Thunk(forall (B : CType) . Bool -> Thunk B -> Thunk B -> B) = {
  fn B b thn els ->
    match b
    | True()  -> ! thn
    | False() -> ! els
    end
};
pub def ifc : Thunk(forall (B : CType) . Thunk(Ret Bool) -> Thunk B -> Thunk B -> B) = {
  fn B b thn els ->
    do b <- ! b;
    ! if @(B) b thn els
};


## arithmetic operations

### we support the constructors externally because
### the parsers of their constructors are customized
### so the type is registered as a data type but the constructors
### are not implemented as internal constructors
pub extern data Int end

pub extern def add : Thunk(Int -> Int -> Ret Int);
pub extern def sub : Thunk(Int -> Int -> Ret Int);
pub extern def mul : Thunk(Int -> Int -> Ret Int);
pub extern def div : Thunk(Int -> Int -> Ret Int);
pub extern def mod : Thunk(Int -> Int -> Ret Int);

pub extern def int_eq : Thunk(Int -> Int -> Ret Bool);
pub extern def int_lt : Thunk(Int -> Int -> Ret Bool);
pub extern def int_gt : Thunk(Int -> Int -> Ret Bool);


## string operations

pub extern data Char end
pub extern data String end
### we support the constructors externally

pub extern def str_length : Thunk(String -> Ret Int);
pub extern def str_append : Thunk(String -> String -> Ret String);
pub extern def str_eq : Thunk(String -> String -> Ret Bool);
pub extern def str_index : Thunk(String -> Int -> Ret Char);

pub def char_eq: Thunk(Char -> Char -> Ret Bool) = {
  fn (c: Char) (c': Char) ->
    do c <- ! char_to_str c;
    do c' <- ! char_to_str c';
    ! str_eq c c'
};


## conversions

pub def unit_to_str : Thunk(Unit -> Ret String) = {
  fn (_u : Unit) -> ret "()"
};
pub def bool_to_str : Thunk(Bool -> Ret String) = {
  fn (b : Bool) ->
    match b
    | True() -> ret "True"
    | False() -> ret "False"
    end
};

pub extern def int_to_str : Thunk(Int -> Ret(String));
pub extern def char_to_str : Thunk(Char -> Ret(String));
pub extern def char_to_int : Thunk(Char -> Ret(Int));
pub extern def str_to_int : Thunk(String -> Ret(Int));


## the List and LList types

pub data List (A : VType) where
  | Nil()
  | Cons(A, List A)
end

pub def rec foldl : forall (A : VType) (R : VType) . List A -> Thunk(A -> R -> Ret(R)) -> R -> Ret(R) =
  fn A R l step s ->
    match l
    | Nil() -> ret s
    | Cons(x, xs) -> (
      do s' <- ! step x s;
      ! foldl @(A) @(R) xs step s'
    )
    end
end

pub data LListV (A : VType) (B : CType) where
  | Nil()
  | Cons(A, Thunk(B))
end

pub codata LList (A : VType) where
  | .run(): Ret (LListV A (LList A))
end


## some OS operations

pub extern codata OS end
pub extern def write_str : Thunk(String -> Thunk(OS) -> OS);
pub extern def read_line : Thunk(Thunk(String -> OS) -> OS);
pub extern def exit : Thunk(Int -> OS);
pub extern def arg_list : Thunk(Thunk(List String -> OS) -> OS);

pub def write_line : Thunk(String -> Thunk(OS) -> OS) = {
  fn (s: String) (k: Thunk(OS)) ->
    do s <- ! str_append s "\n";
    ! write_str s k
};

pub def write_int : Thunk(Int -> Thunk(OS) -> OS) = {
  fn (i: Int) (k: Thunk(OS)) ->
    do s <- ! int_to_str i;
    ! write_str s k
};

pub def write_int_line : Thunk(Int -> Thunk(OS) -> OS) = {
  fn (i: Int) (k: Thunk(OS)) ->
    do s <- ! int_to_str i;
    ! write_line s k
};

pub def panic : Thunk(String -> OS) = {
  fn (msg: String) ->
    do msg <- ! str_append "Program panicked with message: " msg;
    ! write_line msg { ! exit 1 }
};
