data Option (A : VType) where
| None()
| Some(A)
end

data Pair (A : VType) (A' : VType) where
| Cons(A, A')
end

define head : U(forall (A : VType) . U(LList A) -> F(Option A)) = {
  fn (A : VType) -> fn xs -> (
    do xs' <- ! xs .run();
    match xs'
    | Nil() -> ret None()
    | Cons(x, tl) -> ret Some(x)
    end
  )
}
;

define rec foldr : forall (A : VType) (B : CType) . U(LList A) -> U(B) -> U(A -> U(B) -> B) -> B =
  fn (A : VType) (B : CType) -> fn xs b f -> (
    do xsv <- ! xs .run();
    match xsv
    | Nil() -> ! b
    | Cons(hd, tl) -> ! f hd {! foldr @(A) @(B) tl b f}
    end
  )
;

define rec fn print_llint (xs : U(LList Int)) (next : U(OS)) : OS =
  ! foldr @(Int) @(OS) xs {! write_str "\n" next} {fn (x) (b) -> ! write_int x {! write_str " " b}}
;

define rec forever : forall (A : VType) . A -> LList A =
  fn (A : VType) -> fn x ->
  comatch
  | .run() -> ret Cons(x, { ! forever @(A) x })
  end
;

# When I define a recursive function, a thunk is not needed.

define nil : U(forall (A : VType) . LList A) = {
  fn (A : VType) ->
  comatch | .run() -> ret Nil() end
};

define cons : U(forall (A : VType) . A -> U(LList A) -> LList A) = {
  fn (A : VType) -> fn hd tl ->
  comatch 
  | .run() -> ret Cons(hd, tl)
  end
};

define append : U(forall (A : VType) . U(LList A) -> U(LList A) -> LList A) = {
  fn (A : VType) -> fn xs ys ->
    ! foldr @(A) @(LList A) xs ys {
      fn x b -> ! cons @(A) x b
    }
};

define rec bind : forall (A : VType) (A' : VType). U(LList A) -> U(A -> LList A') -> LList A' =
 fn (A : VType) (A' : VType) -> fn xs f ->
  ! foldr @(A) @(LList A') xs {comatch | .run() -> ret Nil() end} {
    fn x b ->
      ! append @(A') {! f x} b
  };

define squash : U(forall (A : VType) .U(LList (U(LList A))) -> LList A) = {
  fn (A : VType) -> fn xs ->
    ! bind @(U(LList A)) @(A) xs {fn x -> ! x}
};

define pair : U(forall (A : VType) (A' : VType) . A -> A' -> F(Pair A A')) = {
  fn (A : VType) (A' : VType) -> fn x y ->
    ret Cons(x, y)
};

define map2 : U(forall (A : VType) (A' : VType) (R : VType) . U(A -> A' -> F(R)) -> U(LList A) -> U(LList A') -> LList R) = {
  fn (A : VType) (A' : VType) (R : VType) -> fn f xs ys ->
  ! foldr @(A) @(LList R) xs {! nil @(R)} {
    fn x acc ->
     ! foldr @(A') @(LList R) ys acc {
      fn y acc' ->
        do r <- ! f x y;
        ! cons @(R) r acc'
     }
  }
};

define cart_prod : U(forall (A : VType) (A' : VType) . U(LList A) -> U(LList A') -> LList (Pair A A')) = {
  fn (A : VType) (A' : VType) -> fn xs ys ->
    ! map2 @(A) @(A') @(Pair A A') {! pair @(A) @(A')} xs ys
}  
;

let nilist : U(LList Int) = {comatch | .run() -> ret Nil() end} in
let x1 : U(LList Int) = {comatch | .run() -> ret Cons(1, nilist) end} in
let x2 : U(LList Int) = {comatch | .run() -> ret Cons(2, x1) end} in
let x3 : U(LList Int) = {comatch | .run() -> ret Cons(3, x2) end} in
let x4 : U(LList Int) = {! append @(Int) x3 x3} in
! print_llint x4 {! exit 0}


