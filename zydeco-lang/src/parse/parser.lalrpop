use crate::{
    lex::token::*,
    parse::syntax::*,
    syntax::{binders::*, TCtor},
    utils::ann::*,
};
grammar<'input>(input: &'input str);


//* -------------------------------- TopLevel -------------------------------- */

pub Zydeco: Program = <decls:Decl*> <comp:Boxed<Comp>> => Program {
    decls,
    comp,
    ann: ann(),
};

pub Declarations: Vec<Declare> = <Decl*>;

pub Expression: ValOrComp = {
    <val : Boxed<Val>>  => ValOrComp::Val(*val),
    <comp: Boxed<Comp>> => ValOrComp::Comp(*comp),
}


//* ------------------------------ Declarations ------------------------------ */

Decl: Declare = {
    <ext:"extern"?> "data" <name:TypeV> <params:TParam*> "where" <ctors:CtorBranch*> "end" => {
        Declare::Data(Data {
            name,
            params,
            ctors,
            ann: ann(),
        })
    },
    <ext:"extern"?> "codata" <name:TypeV> <params:TParam*> "where" <dtors:DtorBranch*> "end"=> {
        Declare::Codata(Codata {
            name,
            params,
            dtors,
            ann: ann(),
        })
    },
    <p:"pub"?> <ext:"extern"?> "define" <binding:BindDefVal<"=">> ";" => {
        let (name, ty, def) = binding;
        Declare::Define {
            public: p.is_some(),
            name,
            ty,
            def,
            ann: ann(),
        }
    },
}

TParam: (TypeV, Kind) = {
    <name:TypeV> ":" <kind:Kind> => (name, kind),
}

CtorBranch: (CtorV, Vec<Type>) = {
    "|" <ctor:CtorV> "(" <args:SepByEnd<",", ")", TVal>> => {
        (ctor, args)
    }
}

DtorBranch: (DtorV, Vec<Type>, Type) = {
    "|" "." <dtor:DtorV> "(" <args:SepByEnd<",", ")", TVal>> ":" <res:TComp> => {
        (dtor, args, res)
    }
}

//* ------------------------------- Expressions ------------------------------ */


Comp: Compute = {
    CompHead,
    "let" <bindings:SepByEnd<",",  ";" , BindVal<"=">>><body:Boxed<Comp>> => {
        *bindings.into_iter().rev().fold(body, |body, binding| Box::new(Compute::Let {
            binding, body, ann: ann()
        }))
    },
    "let" "rec" <binding:BindComp<"=">> ";" <e:Boxed<Comp>> => {
        let (x, tcomp, body) = binding;
        let tval = tcomp.and_then(|tcomp| Some(Box::new(Type { ctor: TCtor::Thunk, args: vec![*tcomp], ann: ann() })));
        Compute::Let {
            binding: (x.clone(), tval.clone(), Box::new(Value::Thunk(Box::new(Compute::Rec {
                arg: (x, tval), body, ann: ann()
            }), ann()))),
            body: e,
            ann: ann(),
        }
    },
    "do" <bindings:SepByEnd<",",  ";", BindComp<"<-">>> <body:Boxed<Comp>> => {
        *bindings.into_iter().rev().fold(body, |body, binding| Box::new(Compute::Do {
            binding, body, ann: ann()
        }))
    },
    "fn" "(" <args:SepByEnd<",", ")", FnArg>> "->" <e:Boxed<Comp>> =>
        *args.into_iter().rev().fold(e, |body, arg| Box::new(Compute::Lam{
            arg, body, ann: ann()
        })),
    "rec" "(" <args:SepByEnd<",", ")", FnArg>> "->" <e:Boxed<Comp>> =>
        *args.into_iter().rev().fold(e, |body, arg| Box::new(Compute::Rec{
            arg, body, ann: ann()
        })),
    "match" <scrut:Boxed<Val>> <cases:MatchBranches> => Compute::Match {
        scrut, cases, ann: ann()
    },
    "comatch" <cases:CoMatchBranches> => Compute::CoMatch {
        cases, ann: ann()
    },
}

CompHead: Compute = {
    CompAtom,
    <e:Boxed<CompHead>> <v:Boxed<Val>> => Compute::App(e, v, ann()),
    <body:Boxed<CompHead>> "." <dtor:DtorV> "(" <args:SepByEnd<",", ")", Val>> => Compute::CoApp {
        body, dtor, args, ann: ann()
    },
}

CompAtom: Compute = {
    "(" <Comp> ")" => <>,
    "!" <v:Boxed<Val>> => Compute::Force(v, ann()),
    "ret" <v:Boxed<Val>> => Compute::Return(v, ann()),
}

BindVal<Delim>: (TermV, Option<Box<Type>>, Box<Value>) = {
    <Bind<Delim, Boxed<TVal>, Boxed<Val>>>
}

BindDefVal<Delim>: (TermV, Option<Box<Type>>, Option<Box<Value>>) = {
    <x:TermV> <ty:(":" <Boxed<TVal>>)?> <def:(Rhs<Delim, Boxed<Val>>)?> => (x, ty, def),
}

BindComp<Delim>: (TermV, Option<Box<Type>>, Box<Compute>) = {
    <Bind<Delim, Boxed<TComp>, Boxed<Comp>>>
}

Bind<Delim, Typ, Def>: (TermV, Option<Typ>, Def) = {
    <x:TermV> <ty:(":" <Typ>)?> <delim:Delim> <def:Def> => (x, ty, def),
}

FnArg: (TermV, Option<Box<Type>>) = {
    <x:TermV> <t:(":" <Boxed<TVal>>)?> => (x, t),
}

MatchBranches: Vec<(CtorV, Vec<TermV>, Box<Compute>)> = {
  <mut m: Branches<CtorPat>> => {
    m.into_iter().map(|((c, xs), m)| (c, xs, m)).collect()
  }
}

CoMatchBranches: Vec<(DtorV, Vec<TermV>, Box<Compute>)> = {
  <mut m: Branches<DtorPat>> => {
    m.into_iter().map(|((d, xs), m)| (d, xs, m)).collect()
  }
}

Branches<Pat>: Vec<(Pat, Box<Compute>)> = {
  <mut v: RevBranches<Pat>> => {
    v.reverse();
    v
  }
}

RevBranches<Pat>: Vec<(Pat, Box<Compute>)> = {
  "|" <p: Pat> "->" <e: Boxed<CompHead>> <mut m: RevBranches<Pat>> => {
    m.push((p, e));
    m
  },
  "end" => Vec::new()
}

CtorPat: (CtorV, Vec<TermV>) = {
  <c: CtorV> "(" <vs: SepByEnd<",", ")", TermV>> => (c, vs)
}

DtorPat: (DtorV, Vec<TermV>) = {
  "." <d: DtorV> "(" <vs: SepByEnd<",", ")", TermV>> => (d, vs)
}

//* ---------------------------------- Value --------------------------------- */
Val: Value = {
    "(" <Val> ")" => <>,
    <x:TermV> => Value::Var(x, ann()),
    "{" <e:Boxed<Comp>> "}" => Value::Thunk(e, ann()),
    <ctor:CtorV> "(" <vs:SepByEnd<",", ")", <Val>>> => Value::Ctor(ctor, vs, ann()),
    <n:Int> => Value::Int(n, ann()),
    <s:Str> => Value::String(s, ann()),
    <c:Char> => Value::Char(c, ann()),
}


//* ---------------------------------- Types --------------------------------- */

// Application T1 T2
// Variables   V
// Arrows      T1 -> T2
// Parens      ( T )

// An arrow can't be immediately on the left of an app

Type: Type = {
  <s: SynType> => *s.lower()
}

SynType: SynType = {
  <tv: Boxed<AppType>> "->" <tc: Boxed<SynType>> => SynType::Arr(tv, tc, ann()),
  AppType
}


AtomType: SynType = {
  <ctor: TCtor> => SynType::Basic(ctor, ann()),
  "(" <SynType> ")" => <>,
}

AppType: SynType = {
  <f: Boxed<AppType>> <a: Boxed<AtomType>> => SynType::App(f, a, ann()),
  AtomType,
}

TCtor: TCtor = {
  <x: TypeV> => TCtor::Var(x),
  "OS" => TCtor::OS,
  "F" => TCtor::Ret,
  "U" => TCtor::Thunk,
}

TComp: Type = Type;
TVal: Type = Type;

// TComp: Type = {
//     <x:TypeV> => Type::Var(x, ann()),
//     "F" "(" <t:Boxed<TVal>> ")" => Type::Ret(t, ann()),
//     <tv:Boxed<TVal>> "->" <tc:Boxed<TComp>> => Type::Lam(tv, tc, ann()),
//     "OS" => Type::OS,
//     "(" <TComp> ")" => <>,
// }

// TVal: Type = {
//     <x:TypeV> => Type::Var(x, ann()),
//     "U" "(" <t:Boxed<TComp>> ")" => Type::Thunk(t, ann()),
//     "(" <TVal> ")" => <>,
// }

//* ---------------------------------- Kinds --------------------------------- */

Kind: Kind = {
    "VType" => Kind::VType,
    "CType" => Kind::CType,
}

//* -------------------------------- Terminals ------------------------------- */

CtorV: CtorV = <UpperId> => CtorV::new(<>, ann());
DtorV: DtorV = <LowerId> => DtorV::new(<>, ann());
TypeV: TypeV = <UpperId> => TypeV::new(<>, ann());
TermV: TermV = <LowerId> => TermV::new(<>, ann());

UpperId: String = "UpperId" => String::from(<>);
LowerId: String = "LowerId" => String::from(<>);

Int: i64 = <s:"NumLit"> => s.parse().unwrap();

Str: String = <s:"StrLit"> => 
    s[1..s.len()-1].to_string().replace("\\\"", "\"");

Char: char = <s:"CharLit"> => s.chars().nth(1).unwrap();


//* --------------------------------- Tokens --------------------------------- */

extern {
    type Location = usize;
    
    enum Tok<'input> {
        "UpperId" => Tok::UpperIdent(<&'input str>),
        "LowerId" => Tok::LowerIdent(<&'input str>),

        "data" => Tok::Data,
        "codata" => Tok::Codata,
        "end" => Tok::End,
        "where" => Tok::Where,
        "pub" => Tok::Pub,
        "extern" => Tok::Extern,
        "define" => Tok::Define,
        "let" => Tok::Let,
        "do" => Tok::Do,
        "ret" => Tok::Ret,
        "fn" => Tok::Fn,
        "rec" => Tok::Rec,
        "match" => Tok::Match,
        "comatch" => Tok::Comatch,

        "NumLit" => Tok::NumLit(<&'input str>),
        "StrLit" => Tok::StrLit(<&'input str>),
        "CharLit" => Tok::CharLit(<&'input str>),

        "VType" => Tok::VType,
        "CType" => Tok::CType,

        "F" => Tok::RetType,
        "U" => Tok::CompType,
        "OS" => Tok::OSType,

        "(" => Tok::ParenOpen,
        ")" => Tok::ParenClose,
        "{" => Tok::BraceOpen,
        "}" => Tok::BraceClose,
        "," => Tok::Comma,
        ":" => Tok::Colon,
        "=" => Tok::Equals,
        ";" => Tok::Semicolon,
        "!" => Tok::Force,
        "|" => Tok::Branch,
        "." => Tok::Dot,
        "->" => Tok::Arrow,
        "<-" => Tok::Assign,
    }
}

//* -------------------------------- Utilities ------------------------------- */

// SepBy<Sym, T>: Vec<T> = {
//     <mut v: (<T> Sym)*> <last: T?> => {
//         match last {
//             None => { },
//             Some(t) => { v.push(t); }
//         };
//         v
//     }
// }

SepByEnd<Sep, End, T>: Vec<T> = {
    <mut v: (<T> Sep)*> <last: T?> End => {
        match last {
            None => { },
            Some(t) => { v.push(t); }
        };
        v
    }
}


// Kleene<Sym, T>: Vec<T> = {
//     Sym? => vec![],
//     Once<Sym, T>,
// }

// Once<Sym, T>: Vec<T> = {
//     <e:T> <mut v:Rhs<Sym, T>*> <s:(<Sym>)?> => {
//         v.insert(0, e);
//         v
//     }
// }

Lhs<L, R>: L = {
    <l:L> <r:R> => l,
}
Rhs<L, R>: R = {
    <l:L> <r:R> => r,
}

Boxed<T>: Box<T> = {
    T => Box::new(<>)
}
