use crate::{
    lex::token::*,
    parse::syntax::*,
    utils::ann::*,
};
grammar<'input>(input: &'input str);


//* -------------------------------- TopLevel -------------------------------- */

pub Zydeco: Program = <decls:Decl*> <comp:Boxed<Comp>> => Program {
    decls,
    comp,
    ann: ann(),
};

pub Declarations: Vec<Declare> = <Decl*>;

pub Expression: ValOrComp = {
    <val : Boxed<Val>>  => ValOrComp::Val(*val),
    <comp: Boxed<Comp>> => ValOrComp::Comp(*comp),
}


//* ------------------------------ Declarations ------------------------------ */

Decl: Declare = {
    <ext:"extern"?> "data" <name:TVar> "where" <ctors:CtorBranch*> => Declare::Data {
        name,
        ctors,
        ann: ann(),
    },
    <ext:"extern"?> "codata" <name:TVar> "where" <dtors:DtorBranch*> => Declare::Codata {
        name,
        dtors,
        ann: ann(),
    },
    <p:"pub"?> <ext:"extern"?> "define" <binding:BindDefVal<"=">> ";" => {
        let (name, ty, def) = binding;
        Declare::Define {
            public: p.is_some(),
            name,
            ty,
            def,
            ann: ann(),
        }
    },
}

CtorBranch: (Ctor, Vec<Type>) = {
    "|" <ctor:Ctor> "(" <args:Kleene<",", TVal>> ")" => {
        (ctor, args)
    }
}

DtorBranch: (Dtor, Vec<Type>, Type) = {
    "." <dtor:Dtor> "(" <args:Kleene<",", TVal>> ")" ":" <res:TComp> => {
        (dtor, args, res)
    }
}

//* ------------------------------- Expressions ------------------------------ */
Comp: Compute = {
    CompHead,
    "let" <bindings:Once<",", BindVal<"=">>> ";" <body:Boxed<Comp>> => {
        *bindings.into_iter().rev().fold(body, |body, binding| Box::new(Compute::Let {
            binding, body, ann: ann()
        }))
    },
    "let" "rec" <binding:BindComp<"=">> ";" <e:Boxed<Comp>> => {
        let (x, tcomp, body) = binding;
        let tval = tcomp.and_then(|tcomp| Some(Box::new(Type::Thunk(tcomp, ann()))));
        Compute::Let {
            binding: (x.clone(), tval.clone(), Box::new(Value::Thunk(Box::new(Compute::Rec {
                arg: (x, tval), body, ann: ann()
            }), ann()))),
            body: e,
            ann: ann(),
        }
    },
    "do" <bindings:Once<",", BindComp<"<-">>> ";" <body:Boxed<Comp>> => {
        *bindings.into_iter().rev().fold(body, |body, binding| Box::new(Compute::Do {
            binding, body, ann: ann()
        }))
    },
    "fn" "(" <args:Once<",", FnArg>> ")" "->" <e:Boxed<Comp>> =>
        *args.into_iter().rev().fold(e, |body, arg| Box::new(Compute::Lam{
            arg, body, ann: ann()
        })),
    "rec" "(" <args:Once<",", FnArg>> ")" "->" <e:Boxed<Comp>> =>
        *args.into_iter().rev().fold(e, |body, arg| Box::new(Compute::Rec{
            arg, body, ann: ann()
        })),
    "match" <scrut:Boxed<Val>> <cases:MatchBranch*> => Compute::Match {
        scrut, cases, ann: ann()
    },
    "comatch" <cases:CoMatchBranch*> => Compute::CoMatch {
        cases, ann: ann()
    },
}

CompHead: Compute = {
    CompAtom,
    <e:Boxed<CompHead>> <v:Boxed<Val>> => Compute::App(e, v, ann()),
    <body:Boxed<CompHead>> "." <dtor:Dtor> "(" <args:Kleene<",", Val>> ")" => Compute::CoApp {
        body, dtor, args, ann: ann()
    },
}

CompAtom: Compute = {
    "(" <Comp> ")" => <>,
    "!" <v:Boxed<Val>> => Compute::Force(v, ann()),
    "ret" <v:Boxed<Val>> => Compute::Return(v, ann()),
}

BindVal<Delim>: (VVar, Option<Box<Type>>, Box<Value>) = {
    <Bind<Delim, TValBox, Boxed<Val>>>
}

BindDefVal<Delim>: (VVar, Option<Box<Type>>, Option<Box<Value>>) = {
    <x:VVar> <ty:(":" <TValBox>)?> <def:(Rhs<Delim, Boxed<Val>>)?> => (x, ty, def),
}

BindComp<Delim>: (VVar, Option<Box<Type>>, Box<Compute>) = {
    <Bind<Delim, TBoxed<Comp>, Boxed<Comp>>>
}

Bind<Delim, Typ, Def>: (VVar, Option<Typ>, Def) = {
    <x:VVar> <ty:(":" <Typ>)?> <delim:Delim> <def:Def> => (x, ty, def),
}

FnArg: (VVar, Option<Box<Type>>) = {
    <x:VVar> <t:(":" <TValBox>)?> => (x, t),
}

MatchBranch: (Ctor, Vec<VVar>, Box<Compute>) = {
    "|" <c:Ctor> "(" <vs:Kleene<",", VVar>> ")" "->" <e:Boxed<CompHead>> => (c, vs, e),
    "|" <c:Ctor> "->" <e:Boxed<CompHead>> => (c, vec!(), e),
}

CoMatchBranch: (Dtor, Vec<VVar>, Box<Compute>) = {
    "|" "." <d:Dtor> "(" <vs:Kleene<",", VVar>> ")" "->" <e:Boxed<CompHead>> => (d, vs, e),
    "|" "." <d:Dtor> "->" <e:Boxed<CompAtom>> => (d, vec!(), e),
}

//* ---------------------------------- Value --------------------------------- */
Val: Value = {
    "(" <Val> ")" => <>,
    <x:VVar> => Value::Var(x, ann()),
    "{" <e:Boxed<Comp>> "}" => Value::Thunk(e, ann()),
    <ctor:Ctor> "(" <vs:Kleene<",", <Val>>> ")" => Value::Ctor(ctor, vs, ann()),
    <n:Int> => Value::Int(n, ann()),
    <s:Str> => Value::String(s, ann()),
    <c:Char> => Value::Char(c, ann()),
}


//* ---------------------------------- Types --------------------------------- */

TBoxed<Comp>: Box<Type> = {
    Boxed<TComp>,
    // "(" <TBoxed<Comp>> ")" => <>,
}

TComp: Type = {
    <x:TVar> => Type::Var(x, ann()),
    "F" "(" <t:TValBox> ")" => Type::Ret(t, ann()),
    <tv:TValBox> "->" <tc:TBoxed<Comp>> => Type::Lam(tv, tc, ann()),
    "OS" => Type::OS,
}

TValBox: Box<Type> = {
    Boxed<TVal>,
    // "(" <TValBox> ")" => <>,
}

TVal: Type = {
    <x:TVar> => Type::Var(x, ann()),
    "U" "(" <t:TBoxed<Comp>> ")" => Type::Thunk(t, ann()),
}


//* ------------------------------- Terminals ------------------------------ */

Ctor: Ctor = <UpperId> => Ctor::new(<>, ann());
Dtor: Dtor = <LowerId> => Dtor::new(<>, ann());
TVar: TVar = <UpperId> => TVar::new(<>, ann());
VVar: VVar = <LowerId> => VVar::new(<>, ann());

UpperId: String = "UpperId" => String::from(<>);
LowerId: String = "LowerId" => String::from(<>);

Int: i64 = <s:"NumLit"> => s.parse().unwrap();

Str: String = <s:"StrLit"> => 
    s[1..s.len()-1].to_string().replace("\\\"", "\"");

Char: char = <s:"CharLit"> => s.chars().nth(1).unwrap();


//* --------------------------------- Tokens --------------------------------- */

extern {
    type Location = usize;
    
    enum Tok<'input> {
        "UpperId" => Tok::UpperIdent(<&'input str>),
        "LowerId" => Tok::LowerIdent(<&'input str>),

        "data" => Tok::Data,
        "codata" => Tok::Codata,
        "where" => Tok::Where,
        "pub" => Tok::Pub,
        "extern" => Tok::Extern,
        "define" => Tok::Define,
        "let" => Tok::Let,
        "do" => Tok::Do,
        "ret" => Tok::Ret,
        "fn" => Tok::Fn,
        "rec" => Tok::Rec,
        "match" => Tok::Match,
        "comatch" => Tok::Comatch,

        "NumLit" => Tok::NumLit(<&'input str>),
        "StrLit" => Tok::StrLit(<&'input str>),
        "CharLit" => Tok::CharLit(<&'input str>),

        "F" => Tok::RetType,
        "U" => Tok::CompType,
        "OS" => Tok::OSType,

        "(" => Tok::ParenOpen,
        ")" => Tok::ParenClose,
        "{" => Tok::BraceOpen,
        "}" => Tok::BraceClose,
        "," => Tok::Comma,
        ":" => Tok::Colon,
        "=" => Tok::Equals,
        ";" => Tok::Semicolon,
        "!" => Tok::Force,
        "|" => Tok::Branch,
        "." => Tok::Dot,
        "->" => Tok::Arrow,
        "<-" => Tok::Assign,
    }
}

//* -------------------------------- Utilities ------------------------------- */

Kleene<Sym, T>: Vec<T> = {
    Sym? => vec![],
    Once<Sym, T>,
}
Once<Sym, T>: Vec<T> = {
    <e:T> <mut v:Rhs<Sym, T>*> <s:(<Sym>)?> => {
        v.insert(0, e);
        v
    }
}

Lhs<L, R>: L = {
    <l:L> <r:R> => l,
}
Rhs<L, R>: R = {
    <l:L> <r:R> => r,
}

Boxed<T>: Box<T> = {
    T => Box::new(<>)
}
