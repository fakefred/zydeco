use crate::{
    parse::{syntax::*, token::*, escape},
    syntax::DeclSymbol,
    utils::span::*,
};

grammar<'input>(input: &'input str);

//* --------------------------------- Module --------------------------------- */

pub Zydeco: Span<Program> = Span<Program>;
pub ZydecoModule: Span<Module> = {
    // Span<Module>,
    <declarations:Span<DeclSymbol<Declaration>*>> => {
        declarations.info.make(Module {
            name: None,
            declarations: declarations.inner,
        })
    },
};

Program: Program = {
    <module:ZydecoModule> <entry:Span<TermComputation>> => Program {
        module, entry,
    },
};

Module: Module = {
    "module" <name:UpperId> "where"
        <declarations:DeclSymbol<Declaration>*>
    "end" => Module {
        name: Some(name), declarations
    },
};

DeclSymbol<T>: DeclSymbol<T> = {
    <public:"pub"?> <external:"extern"?> <inner:T> => DeclSymbol {
        public: public.is_some(),
        external: external.is_some(),
        inner,
    }
};

Declaration: Declaration = {
    <Module> => <>.into(),
    "data" <name:TypeV> <params:TypeKindPattern*>
        <ctors:("where" <DataBr*>)?>
    "end" => Data {
        name, params, ctors: ctors.unwrap_or_default(),
    }.into(),
    "codata" <name:TypeV> <params:TypeKindPattern*>
        <dtors:("where" <CodataBr*>)?>
    "end" => Codata {
        name, params, dtors: dtors.unwrap_or_default(),
    }.into(),
    "alias" <name:TypeV> <params:TypeKindPattern*> "=" <ty:Box<Span<Type>>> "end" => Alias {
        name, params, ty,
    }.into(),
    "define" <gen:GenLet> DefineEnd => gen.into(),
};

DefineEnd: () = {
    "end" => (),
    ";" => (),
};

DataBr: DataBr<CtorV, Span<Type>> = {
    "|" <ctor:CtorV> <args:SepByDelim<"(", ",", <Span<Type>>, ")">> => {
        DataBr(ctor, args)
    }
};

CodataBr: CodataBr<DtorV, Span<Type>> = {
    "|" "." <dtor:DtorV> <args:SepByDelim<"(", ",", <Span<Type>>, ")">> ":"
    <ty:Span<Type>> => {
        CodataBr(dtor, args, ty)
    }
};


//* ---------------------------------- Kind ---------------------------------- */

Kind: Kind = {
    "VType" => Kind::VType,
    "CType" => Kind::CType,
};

//* ---------------------------------- Type ---------------------------------- */

Type: Type = {
    "forall" <params:TypeKindPattern+> "." <ty:Box<Span<TypeArrow>>> => {
        Forall(params, ty).into()
    },
    "exists" <params:TypeKindPattern+> "." <ty:Box<Span<TypeArrow>>> => {
        Exists(params, ty).into()
    },
    TypeArrow,
};

TypeArrow: Type = {
    <t:Box<Span<TypeApp>>> "->" <ty:Box<Span<Type>>> => {
        Arrow(t, ty).into()
    },
    TypeApp,
};

TypeApp: Type = {
    <t:Box<Span<TypeApp>>> <ty:Box<Span<TypeAtom>>> => {
        TypeApp(t, ty).into()
    },
    TypeAtom,
};

TypeAtom: Type = {
    "(" <Type> ")" => <>,
    <TypeV> => <>.into(),
    "_?" => Hole.into(),
};

//* --------------------------------- Pattern -------------------------------- */

TypeKindPattern: TypeKindPattern = "(" <name:TypeV> ":" <kind:Span<Kind>> ")" => (name, kind);

TypePattern: TypePattern = {
    "(" <name:TypeV> <kind: (":" <Span<Kind>>)?> ")" => (name, kind),
    <name:TypeV> => (name, None),
};

TermPattern: TermPattern = {
    "(" <v:TermV> <ty:(":" <Span<Type>>)?> ")" => (v, ty),
    TermV => (<>, None),
};

Pattern: Pattern = {
    <TypePattern> => <>.into(),
    <TermPattern> => <>.into(),
};

//* ---------------------------------- Term ---------------------------------- */

pub TermSpan: Span<Term> = Span<Term>;

Term: Term = {
    <TermComputation> => <>.into(),
    <TermValue> => <>.into(),
};

TermValue: TermValue = {
    "(" <TermValue> ")" => <>.into(),
    "(" <tv:Box<Span<TermValue>>> "::" <ty:Span<Type>> ")" => Annotation {
        term: tv,
        ty,
    }.into(),
    <TermV> => <>.into(),
    "{" <tc:Box<Span<TermComputation>>> "}" => Thunk(tc).into(),
    <ctor:CtorV> <args:SepByDelim<"(", ",", Span<TermValue>, ")">> => Ctor {
        ctor, args,
    }.into(),
    <Literal> => <>.into(),
    "pack" "(" <ty:Box<Span<Type>>> "," <body:Box<Span<TermValue>>> ")" => Pack {
        ty, body,
    }.into(),
};

TermComputation: TermComputation = {
    TermComputationRight,
    "let" <gen:GenLet> LetSep <body:Box<Span<TermComputation>>> => Let {
        gen, body,
    }.into(),
    "do" <var:TermPattern> "<-"
        <comp:Box<Span<TermComputation>>> ";"
    <body:Box<Span<TermComputation>>> => Do {
        var, comp, body,
    }.into(),
    "rec" <var:TermPattern> "->" <body:Box<Span<TermComputation>>> => Rec {
        var, body,
    }.into(),
    "match" <scrut:Box<Span<TermValue>>> <arms:MatchBr*> "end" => Match {
        scrut, arms,
    }.into(),
    "comatch" <arms:ComatchBr*> "end" => Comatch {
        arms,
    }.into(),
    "fn" <params:Pattern+> "->" <body:Box<Span<TermComputation>>> => Abstraction {
        params, body,
    }.into(),
    "match" <scrut:Box<Span<TermValue>>> 
    "|"? "pack" "(" <tvar:TypeV> "," <var:TermV> ")" "->"
        <body:Box<Span<TermComputation>>> 
    "end" => MatchPack {
        scrut, tvar, var, body,
    }.into(),
};

LetSep: () = {
    ";" => (),
    "in" => (),
};

TermComputationRight: TermComputation = {
    TermComputationAtom,
    <body:Box<Span<TermComputationRight>>> <arg:Box<Span<TermValue>>> => Application {
        body, arg,
    }.into(),
    <body:Box<Span<TermComputationRight>>> "@" "(" <arg:Box<Span<Type>>> ")" => TyAppTerm {
        body, arg,
    }.into(),
    <body:Box<Span<TermComputationRight>>> "." <dtor:DtorV>
    <args:SepByDelim<"(", ",", Span<TermValue>, ")">> => Dtor {
        body, dtor, args,
    }.into(),
};

TermComputationAtom: TermComputation = {
    "(" <tc:TermComputation> ")" => tc.into(),
    "(" <tc:Box<Span<TermComputation>>> "::" <ty:Span<Type>> ")" => Annotation {
        term: tc, ty,
    }.into(),
    "ret" <v:Box<Span<TermValue>>> => Ret(v).into(),
    "!" <v:Box<Span<TermValue>>> => Force(v).into(),
};

GenLet: GenLet = {
    <rec:"rec"?> <fun:"fn"?> <var:TermV> <params:Pattern*>
    <ty:(":" <Span<Type>>)?> <def: ("=" <Box<Span<Term>>>)?> => GenLet {
        rec: rec.is_some(),
        fun: fun.is_some(),
        name: (var, ty),
        params,
        def,
    }
};

MatchBr: Matcher<CtorV, TermV, Span<TermComputation>> = {
    "|" <ctor:CtorV> <vars:SepByDelim<"(", ",", TermV, ")">> "->"
    <body:Span<TermComputation>> => Matcher {
        ctor, vars, body
    }
};

ComatchBr: Comatcher<DtorV, TermV, Span<TermComputation>> = {
    "|" "." <dtor:DtorV> <vars:SepByDelim<"(", ",", TermV, ")">> "->"
    <body:Span<TermComputation>> => Comatcher {
        dtor, vars, body
    }
};

Literal: Literal = {
    <Int> => <>.into(),
    <String> => <>.into(),
    <Char> => <>.into(),
};

//* -------------------------------- Terminals ------------------------------- */

CtorV: CtorV = <Span<UpperId>> => <>.into();
DtorV: DtorV = <Span<LowerId>> => <>.into();
TypeV: TypeV = <Span<UpperId>> => <>.into();
TermV: TermV = <Span<LowerId>> => <>.into();

UpperId: String = "UpperId" => <>.into();
LowerId: String = "LowerId" => <>.into();

Int: i64 = <s:"NumLit"> => s.parse().unwrap();
String: String = <s:"StrLit"> => escape::apply_string_escapes(&s[1..s.len()-1]);
Char: char = <s:"CharLit"> => escape::apply_char_escapes(s);

//* -------------------------------- Utilities ------------------------------- */

Span<T>: Span<T> = {
    <l:@L> <inner:T> <r:@R> => SpanInfo::new(l,r).make(inner)
};

Box<T>: Box<T> = {
    <inner:T> => Box::new(inner)
};

SepByDelim<Start, Sep, T, End>: Vec<T> = {
    Start <mut v: (<T> Sep)*> <last: T?> End => {
        match last {
            None => { },
            Some(t) => { v.push(t); }
        };
        v
    }
};

//* --------------------------------- Tokens --------------------------------- */

extern {
    type Location = usize;
    
    enum Tok<'input> {
        "UpperId" => Tok::UpperIdent(<&'input str>),
        "LowerId" => Tok::LowerIdent(<&'input str>),

        "module" => Tok::Module,
        "where" => Tok::Where,
        "end" => Tok::End,
        "pub" => Tok::Pub,
        "extern" => Tok::Extern,
        "data" => Tok::Data,
        "codata" => Tok::Codata,
        "alias" => Tok::Alias,
        "define" => Tok::Define,
        "let" => Tok::Let,
        "in" => Tok::In,
        "do" => Tok::Do,
        "ret" => Tok::Ret,
        "fn" => Tok::Fn,
        "rec" => Tok::Rec,
        "match" => Tok::Match,
        "comatch" => Tok::Comatch,
        "forall" => Tok::Forall,
        "exists" => Tok::Exists,
        "@" => Tok::At,
        "pack" => Tok::Pack,

        "NumLit" => Tok::NumLit(<&'input str>),
        "StrLit" => Tok::StrLit(<&'input str>),
        "CharLit" => Tok::CharLit(<&'input str>),

        "VType" => Tok::VType,
        "CType" => Tok::CType,

        "(" => Tok::ParenOpen,
        ")" => Tok::ParenClose,
        "[" => Tok::BracketOpen,
        "]" => Tok::BracketClose,
        "{" => Tok::BraceOpen,
        "}" => Tok::BraceClose,
        "," => Tok::Comma,
        ":" => Tok::Colon,
        "::" => Tok::ColonColon,
        "=" => Tok::Equals,
        ";" => Tok::Semicolon,
        "!" => Tok::Force,
        "|" => Tok::Branch,
        "." => Tok::Dot,
        "->" => Tok::Arrow,
        "<-" => Tok::Assign,
        "_?" => Tok::Hole,
    }
}

