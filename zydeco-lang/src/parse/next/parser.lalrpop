use crate::{
    parse::{next::*, token::*},
    syntax::{ann::*, TCtor, DeclSymbol},
};
use crate::parse::{apply_string_escapes, apply_char_escapes};

grammar<'input>(input: &'input str);

//* --------------------------------- Module --------------------------------- */

pub Zydeco: Module = {
    "module" <name:String> "where"
    <declarations:DeclSymbol<Declaration>*>
    <entry:Ann<TermComputation>> => Module {
        name: Some(name),
        declarations,
        entry,
    }
};

DeclSymbol<T>: DeclSymbol<T> = {
    <public:"pub"?> <external:"extern"?> <inner:T> => DeclSymbol {
        public: public.is_some(),
        external: external.is_some(),
        inner,
    }
};

Declaration: Declaration = {
    "data" <name:TypeV> <params:TypePattern*> "where"
        <ctors:DataBr*>
    "end" => Data {
        name,
        params,
        ctors,
    }.into(),
    "codata" <name:TypeV> <params:TypePattern*> "where"
        <dtors:CodataBr*>
    "end" => Codata {
        name,
        params,
        dtors,
    }.into(),
    "let" <gen:GenLet> "end" => gen.into(),
};

DataBr: DataBr<CtorV, Ann<Type>> = {
    "|" <ctor:CtorV> <args:SepByDelim<"(", ",", <Ann<Type>>, ")">> => {
        DataBr(ctor, args)
    }
};

CodataBr: CodataBr<DtorV, Ann<Type>> = {
    "|" "." <dtor:DtorV> <args:SepByDelim<"(", ",", <Ann<Type>>, ")">> ":"
    <ty:Ann<Type>> => {
        CodataBr(dtor, args, ty)
    }
};


//* ---------------------------------- Kind ---------------------------------- */

Kind: Kind = {
    "VType" => Kind::VType,
    "CType" => Kind::CType,
};

//* ---------------------------------- Type ---------------------------------- */

Type: Type = {
    <t:Box<Ann<Type>>> "->" <ty:Box<Ann<TypeApp>>> => {
        TypeAbs(t, ty).into()
    },
    TypeApp,
};

TypeApp: Type = {
    <t:Box<Ann<TypeApp>>> <ty:Box<Ann<TypeAtom>>> => {
        TypeApp(t, ty).into()
    },
    TypeAtom,
};

TypeAtom: Type = {
    <tc:TCtor> => tc.into(),
    "(" <Type> ")" => <>,
};

TCtor: TCtor = {
    <TypeV> => TCtor::Var(<>),
    "U" => TCtor::Thunk,
    "F" => TCtor::Ret,
    "OS" => TCtor::OS,
    // Fun ?
};

TypePattern: (TypeV, Kind) = "(" <name:TypeV> ":" <kind:Kind> ")" => (name, kind);

//* ---------------------------------- Term ---------------------------------- */

TermValue: TermValue = {
    "(" <TermValue> ")" => <>.into(),
    "(" <tv:Box<Ann<TermValue>>> "::" <ty:Ann<Type>> ")" => TermAnn {
        body: tv,
        ty,
    }.into(),
    <TermV> => <>.into(),
    "{" <tc:Box<Ann<TermComputation>>> "}" => Thunk(tc).into(),
    <ctor:CtorV> <args:SepByDelim<"(", ",", Ann<TermValue>, ")">> => Ctor {
        ctor,
        args,
    }.into(),
    <Literal> => <>.into(),
};

TermComputation: TermComputation = {
    TermComputationRight,
    "let" <gen:GenLet> "in" <body:Box<Ann<TermComputation>>> => Let {
        gen,
        body,
    }.into(),
    "do" <var:TermPattern> "<-"
        <comp:Box<Ann<TermComputation>>> ";"
    <body:Box<Ann<TermComputation>>> => Do {
        var,
        comp,
        body,
    }.into(),
    "rec" <var:TermPattern> "->" <body:Box<Ann<TermComputation>>> => Rec {
        var,
        body,
    }.into(),
    "match" <scrut:Box<Ann<TermValue>>> <arms:MatchBr*> "end" => Match {
        scrut,
        arms,
    }.into(),
    "fn" <params:TermPattern*> <body:Box<Ann<TermComputation>>> => Abstraction {
        params,
        body,
    }.into(),
    "comatch" <arms:ComatchBr*> "end" => CoMatch {
        arms,
    }.into(),
};

TermComputationRight: TermComputation = {
    TermComputationAtom,
    <body:Box<Ann<TermComputationRight>>> <arg:Box<Ann<TermValue>>> => Application {
        body,
        arg,
    }.into(),
    <body:Box<Ann<TermComputationRight>>> "." <dtor:DtorV>
    <args:SepByDelim<"(", ",", Ann<TermValue>, ")">> => Dtor {
        body,
        dtor,
        args,
    }.into(),
};

TermComputationAtom: TermComputation = {
    "(" <tc:TermComputation> ")" => tc.into(),
    "(" <tc:Box<Ann<TermComputation>>> "::" <ty:Ann<Type>> ")" => TermAnn {
        body: tc,
        ty,
    }.into(),
    "ret" <v:Box<Ann<TermValue>>> => Force(v).into(),
    "!" <v:Box<Ann<TermValue>>> => Ret(v).into(),
};

GenLet: GenLet = {
    <rec:"rec"?> <fun:"fn"?> <var:TermV> <params:TermPattern*> <ty:(":" <Ann<Type>>)?> "="
    <def:Box<Ann<TermValue>>> => GenLet {
        rec: rec.is_some(),
        fun: fun.is_some(),
        name: (var, ty),
        params,
        def,
    }
};

MatchBr: Matcher<CtorV, TermV, Ann<TermComputation>> = {
    "|" <ctor:CtorV> <vars:SepByDelim<"(", ",", TermV, ")">> "->"
    <body:Ann<TermComputation>> => Matcher {
        ctor, vars, body
    }
};

ComatchBr: CoMatcher<DtorV, TermV, Ann<TermComputation>> = {
    "|" "." <dtor:DtorV> <vars:SepByDelim<"(", ",", TermV, ")">> "->"
    <body:Ann<TermComputation>> => CoMatcher {
        dtor, vars, body
    }
};

TermPattern: TermPattern = {
    "(" <v:TermV> <ty:(":" <Ann<Type>>)?> ")" => (v, ty)
};

Literal: Literal = {
    <n:Int> => n.into(),
    <s:String> => s.into(),
    <c:Char> => c.into(),
};

//* -------------------------------- Terminals ------------------------------- */

CtorV: CtorV = <Ann<UpperId>> => <>.into();
DtorV: DtorV = <Ann<LowerId>> => <>.into();
TypeV: TypeV = <Ann<UpperId>> => <>.into();
TermV: TermV = <Ann<LowerId>> => <>.into();

UpperId: String = "UpperId" => <>.into();
LowerId: String = "LowerId" => <>.into();


String: String = <s:"StrLit"> => apply_string_escapes(&s[1..s.len()-1]);

Int: i64 = <s:"NumLit"> => s.parse().unwrap();
Char: char = {
    <s:"CharLit"> => s.chars().nth(1).unwrap(),
    <s:"Escape"> => apply_char_escapes(&s[1..s.len()-1]),
};

//* -------------------------------- Utilities ------------------------------- */

Ann<T>: Ann<T> = {
    <l:@L> <inner:T> <r:@R> => ann(l,r).make(inner)
};

Box<T>: Box<T> = {
    <inner:T> => Box::new(inner)
};

SepByEnd<Sep, T, End>: Vec<T> = {
    <mut v: (<T> Sep)*> <last: T?> End => {
        match last {
            None => { },
            Some(t) => { v.push(t); }
        };
        v
    }
};

SepByDelim<Start, Sep, T, End>: Vec<T> = Start <SepByEnd<Sep, T, End>>;

//* --------------------------------- Tokens --------------------------------- */

extern {
    type Location = usize;
    
    enum Tok<'input> {
        "UpperId" => Tok::UpperIdent(<&'input str>),
        "LowerId" => Tok::LowerIdent(<&'input str>),

        "module" => Tok::Module,
        "data" => Tok::Data,
        "codata" => Tok::Codata,
        "end" => Tok::End,
        "where" => Tok::Where,
        "pub" => Tok::Pub,
        "extern" => Tok::Extern,
        "define" => Tok::Define,
        "let" => Tok::Let,
        "in" => Tok::In,
        "do" => Tok::Do,
        "ret" => Tok::Ret,
        "fn" => Tok::Fn,
        "rec" => Tok::Rec,
        "match" => Tok::Match,
        "comatch" => Tok::Comatch,

        "NumLit" => Tok::NumLit(<&'input str>),
        "StrLit" => Tok::StrLit(<&'input str>),
        "CharLit" => Tok::CharLit(<&'input str>),
        "Escape" => Tok::Escape(<&'input str>),

        "VType" => Tok::VType,
        "CType" => Tok::CType,

        "F" => Tok::RetType,
        "U" => Tok::CompType,
        "OS" => Tok::OSType,

        "(" => Tok::ParenOpen,
        ")" => Tok::ParenClose,
        "{" => Tok::BraceOpen,
        "}" => Tok::BraceClose,
        "," => Tok::Comma,
        ":" => Tok::Colon,
        "::" => Tok::ColonColon,
        "=" => Tok::Equals,
        ";" => Tok::Semicolon,
        "!" => Tok::Force,
        "|" => Tok::Branch,
        "." => Tok::Dot,
        "->" => Tok::Arrow,
        "<-" => Tok::Assign,
    }
}

