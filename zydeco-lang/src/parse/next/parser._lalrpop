use crate::{
    parse::{next::*, token::*},
    syntax::{ann::*, binder::*, TCtor},
};
use crate::parse::{apply_string_escapes, apply_char_escapes};

grammar<'input>(input: &'input str);

pub Zydeco: Module = "module" <name:String> "where" <declarations:Decls*> <entry:Ann<TermComputation>> => Module {
    name: Some(name),
    declarations,
    entry
}

pub Declaration: Declaration = {
    <ext:"extern"?> "data" <name:TypeV> <params:TParameter*> "where" <ctors:DataBr*> "end" => Data {
        name,
        params,
        ctors
    }
    <ext:"extern"?> "codata" <name:TypeV> <params:TParameter*> "where" <dtors:CodataBr*> "end" => Codata {
        name,
        params,
        dtors
    }
    <p:"pub"?> <ext:"extern"?> "define" <name:TermV> ":" <ty:Type> <def:("=" Value)?> "end" => Define {
        public: p,
        name,
        ty,
        def
    }
}

DataBr: DataBr = "|" <ctor:CtorV> "(" <args:SepByEnd<",", ")", Type>> => DataBr(ctor, args);

DataBr: DataBr = "|" <ctor:CtorV> "(" <args:SepByEnd<",", ")", Type>> => (ctor, args).into();

CodataBr: CodataBr = "|" "." <dtor:DtorV> "(" <args:SepByEnd<",", ")", Type>> ":" <ty:Type>=> CodataBr(dtor, args, ty);

TParameter: (TypeV, Kind) = <name:TypeV> ":" <kind:Kind> => (name, kind)

// TypeV: TypeV

TermComputation: TermComputation = {
    "(" <tc:BoxAnn<TermComputation>> "::" <ty:Ann<Type>> ")" => TermAnn{
        body: tc,
        ty
    }.into(),
    "!" <v:BoxAnn<TermValue>> => Ret(v).into(),
}

Ann<Rule>: Ann<T> = {
    <l:@L> <content:Rule> <r:@R> => ann(l,r).make(content)
}

BoxAnn<Rule>: Box<Ann<T>> = {
    <l:@L> <content:Rule> <r:@R> => Box::new(ann(l,r).make(content))
}

// BoxAnn<Rule>: Box<Ann<T>> = {
//     <l:@L> <content:Rule> <r:@R> => Box::new(ann(l,r).make(content))
// }

SepByEnd<Sep, End, T>: Vec<T> = {
    <content:T> <s:Sep> <mut rest:SepByEnd<Sep, T, End>> => {
        rest.insert(0, content);
        rest
    }
    <content:T> <e:End> => {
        let mut vec = Vec::new();
        vec.push(content);
        vec
    }
} 