use crate::{
    parse::{next::*, token::*},
    syntax::{ann::*, binder::*, TCtor},
};
use crate::parse::{apply_string_escapes, apply_char_escapes};

grammar<'input>(input: &'input str);


//* --------------------------------- Module --------------------------------- */

pub Zydeco: Module = {
    "module" <name:String> "where" <decls:DeclSymbol<Declaration>*> <entry:Ann<TermComputation>> => Module {
        name: Some(name),
        declarations: decls,
        entry,
    }
}


//* ------------------------------ Declarations ------------------------------ */

DeclSymbol<T>: DeclSymbol<T> = {
    <public:"pub"?> <external:"extern"?> <inner:T> => {
        DeclSymbol {
            public: public.is_some(),
            external: external.is_some(),
            inner,
        }
    }
}

Declaration: Declaration = {
    "data" <name:TypeV> <params:TParam*> "where" <ctors:DataBr*> "end" => Data {
        name,
        params,
        ctors,
    }.into(),
    "codata" <name:TypeV> <params:TParam*> "where" <dtors:CodataBr*> "end" => Codata {
        name,
        params,
        dtors,
    }.into(),
    "define" <name:TermV> <ty:(":" <Type>)?> <def:("=" Value)?> "end" => Define {
        name,
        ty,
        def,
    }.into(),
}

DataBr: DataBr = "|" <ctor:CtorV> <args:SepByDelim<"(", ",", Type, ")">> => DataBr(ctor, args);

CodataBr: CodataBr = "|" "." <dtor:DtorV> <args:SepByDelim<"(", ",", Type, ")">> ":" <ty:Type> => CodataBr(dtor, args, ty);

TParam: (TypeV, Kind) = "(" <name:TypeV> ":" <kind:Kind> ")" => (name, kind);


//* ---------------------------------- Kinds --------------------------------- */

Kind: Kind = {
    "VType" => Kind::VType,
    "CType" => Kind::CType,
}


//* ---------------------------------- Types --------------------------------- */

// Application T1 T2
// Variables   V
// Arrows      T1 -> T2
// Parens      ( T )

// An arrow can't be immediately on the left of an app


Type: Type = {
  <tv: Boxed<AppType>> "->" <tc: Boxed<Type>> => Type::Arr(tv, tc, ann(l,r)),
  AppType
}


AtomType: Type = {
  <ctor: TCtor> => Type::Basic(ctor, ann(l,r)),
  "(" <Type> ")" => <>,
}

AppType: Type = {
  <f: Boxed<AppType>> <a: Boxed<AtomType>> => Type::App(f, a, ann(l,r)),
  AtomType,
}

TCtor: TCtor = {
  <x: TypeV> => TCtor::Var(x),
  "OS" => TCtor::OS,
  "F" => TCtor::Ret,
  "U" => TCtor::Thunk,
}


//* ---------------------------------- Value --------------------------------- */

TermValue: TermValue = {
    "(" <Ann<TermValue>> ")" => <>.into(),
    "(" <tv:BoxAnn<TermValue>> "::" <ty:Ann<Type>> ")" => TermAnn {
        body: tv,
        ty,
    }.into(),
    <TermV> => <>.into(),
    "{" <tc:BoxAnn<TermComputation>> "}" => Thunk(tc).into(),
    <ctor:DtorV> <args:SepByDelim<"(", ",", Ann<TermValue>, ")">> => Dtor {
        ctor,
        args,
    }.into(),
    <Literal> => <>.into(),
}


//* ------------------------------- Computation ------------------------------ */

TermComputation: TermComputation = {
    TermComputationRight,
    "let" <binder:TermV> <ty_ann:(":" Ann<Type>)?> "=" <def:BoxAnn<TermValue>> ";" <body:BoxAnn<TermComputation>> => Let {
        binder,
        ty_ann,
        def,
        body,
    }.into(),
    // How to deal with let rec
    "do" <binder:TermV> <ty_ann:(":" Ann<Type>)?> "<-" <task:BoxAnn<TermComputation>> ";" <body:BoxAnn<TermComputation>> => Do {
        binder,
        ty_ann,
        task,
        body,
    }.into(),
    "rec" "(" <var:TermV> <ty_ann:(":" Ann<Type>)?> ")" "->" <body:BoxAnn<TermComputation>> => Rec {
        var,
        body,
    }.into(),
    "match" <scrut:BoxAnn<TermV>> <arms:MatchBr*> "end" => Match {
        scrut,
        arms,
    }.into(),
    "fn"  <params:SepByDelim<"(", ",", FnArg, ")">> <body:BoxAnn<TermComputation>> => Function {
        params,
        body,
    }.into(),
    "comatch" <arms:ComatchBr*> "end" => CoMatch {
        arms,
    }.into(),
}

TermComputationRight: TermComputation = {
    TermComputationAtom,
    <expr_in:BoxAnn<TermComputationRight>> <args:Ann<TermValue>*> => Application {
        expr_in,
        args,
    }.into(),
    <body:BoxAnn<TermComputationRight>> "." <dtor:DtorV> <args:SepByDelim<"(", ",", Ann<TermValue>, ")">> => Dtor {
        body,
        dtor,
        args,
    }.into(),
}

TermComputationAtom: TermComputation = {
    "(" <TermComputation> ")" => <>.into(),
    "(" <tc:BoxAnn<TermComputationAtom>> "::" <ty:Ann<Type>> ")" => TermAnn {
        body: tc,
        ty,
    }.into(),
    "ret" <v:BoxAnn<TermValue>> => Force(v).into(),
    "!" <v:BoxAnn<TermValue>> => Ret(v).into(),
}


FnArg: (TermV, Option<Ann<Type>>) = {
    <x:TermV> <t:(":" <Ann<Type>>)?> => (x, t),
}

//* -------------------------------- Terminals ------------------------------- */

CtorV: CtorV = <l:@L> <v:UpperId> <r:@R> => CtorV::new(v, ann(l,r));
DtorV: DtorV = <l:@L> <v:LowerId> <r:@R> => DtorV::new(v, ann(l,r));
TypeV: TypeV = <l:@L> <v:UpperId> <r:@R> => TypeV::new(v, ann(l,r));
TermV: TermV = <l:@L> <v:LowerId> <r:@R> => TermV::new(v, ann(l,r));

UpperId: String = "UpperId" => String::from(<>);
LowerId: String = "LowerId" => String::from(<>);

Int: i64 = <s:"NumLit"> => s.parse().unwrap();

Str: String = <s:"StrLit"> => 
    apply_string_escapes(&s[1..s.len()-1]); //todo

// Char: char = <s:"CharLit"> => s.chars().nth(1).unwrap(); //todo
Char: char = {
    <s:"CharLit"> => s.chars().nth(1).unwrap(),
    <s:"Escape"> => apply_char_escapes(&s[1..s.len()-1]),
};


//* --------------------------------- Tokens --------------------------------- */

extern {
    type Location = usize;
    
    enum Tok<'input> {
        "UpperId" => Tok::UpperIdent(<&'input str>),
        "LowerId" => Tok::LowerIdent(<&'input str>),

        "module" => Tok::Module,
        "where" => Tok::Where,
        "end" => Tok::End,
        "pub" => Tok::Pub,
        "extern" => Tok::Extern,
        "define" => Tok::Define,
        "data" => Tok::Data,
        "codata" => Tok::Codata,
        "let" => Tok::Let,
        "do" => Tok::Do,
        "ret" => Tok::Ret,
        "fn" => Tok::Fn,
        "rec" => Tok::Rec,
        "match" => Tok::Match,
        "comatch" => Tok::Comatch,

        "NumLit" => Tok::NumLit(<&'input str>),
        "StrLit" => Tok::StrLit(<&'input str>),
        "CharLit" => Tok::CharLit(<&'input str>),
        "Escape" => Tok::Escape(<&'input str>),

        "VType" => Tok::VType,
        "CType" => Tok::CType,

        "F" => Tok::RetType,
        "U" => Tok::CompType,
        "OS" => Tok::OSType,

        "(" => Tok::ParenOpen,
        ")" => Tok::ParenClose,
        "{" => Tok::BraceOpen,
        "}" => Tok::BraceClose,
        "," => Tok::Comma,
        ":" => Tok::Colon,
        "::" => Tok::ColonColon,
        "=" => Tok::Equals,
        ";" => Tok::Semicolon,
        "!" => Tok::Force,
        "|" => Tok::Branch,
        "." => Tok::Dot,
        "->" => Tok::Arrow,
        "<-" => Tok::Assign,
    }
}


//* -------------------------------- Utilities ------------------------------- */

SepByEnd<Sep, T, End>: Vec<T> = {
    <mut v: (<T> Sep)*> <last: T?> End => {
        match last {
            None => { },
            Some(t) => { v.push(t); }
        };
        v
    }
}

SepByDelim<Start, Sep, T, End>: Vec<T> = {
    <_:Start> <v:SepByEnd<Sep, T, End>> => v,
}

Ann<Rule>: Ann<T> = {
    <l:@L> <content:Rule> <r:@R> => ann(l,r).make(content)
}

BoxAnn<Rule>: Box<Ann<T>> = Boxed<Ann<Rule>>;

Boxed<T>: Box<T> = {
    T => Box::new(<>)
}
