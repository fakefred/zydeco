use crate::{
    parse::{next::*, token::*},
    syntax::{ann::*, binder::*, TCtor},
};
use crate::parse::{apply_string_escapes, apply_char_escapes};

grammar<'input>(input: &'input str);

pub Zydeco: Module = "module" <name:String> "where" <declarations:Decls*> <entry:TermComputation> => Module {
    name: Some(name),
    declarations,
    entry
}

pub Declaration: Declaration = {
    <ext:"extern"?> "data" <name:TypeV> <params:TParameters> "where" <ctors:DataBr*> "end" => Data {
        name,
        params,
        ctors
    }
    <ext:"extern"?> "codata" <name:TypeV> <params:TParameters> "where" <dtors:CodataBr*> "end" => Codata {
        name,
        params,
        dtors
    }
    <p:"pub"?> <ext:"extern"?> "define" <name:TermV> ":" <ty:Type> <def:("=" Value)?> "end" => Define {
        public: p,
        name,
        ty,
        def
    }
}

pub DataBr: DataBr = "|" <ctor:CtorV> "(" <  "," ")">



BoxAnn<Rule>: Box<Ann<T>> = {
    <l:@L> <content:Rule> <r:@R> => Box::new(ann(l,r).make(content))
}

// BoxAnn<Rule>: Box<Ann<T>> = {
//     <l:@L> <content:Rule> <r:@R> => Box::new(ann(l,r).make(content))
// }

SepByEnd<Sep, T, End>: Vec<T> = {
    <content:T> <s:Sep> <mut rest:SepByEnd<Sep, T, End>> => {
        rest.insert(0, content);
        rest
    }
    <content:T> <e:End> => 
} 