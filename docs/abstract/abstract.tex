\documentclass[acmsmall,nonacm]{acmart}
\input{preamble/preamble}

\title{Zydeco: A Stack-Based Call-By-Push-Value Language}
\author{Yuchen Jiang: lighght@umich.edu}
\author{Runze Xue: cactus@umich.edu}

\begin{document}
\renewcommand{\thesection}{\Alph{section}}
\maketitle
\noindent
Affiliation: CSE Department at the University of Michigan

\noindent
Advisor: Max S. New

\noindent
ACM student member number: 8631133

\noindent
Category: Undergraduate

\section{Motivation}

\textit{Call-By-Push-Value(CBPV)}, introduced by Paul Blain Levy, is a programming paradigm that exploits stack for passing arguments when calling functions. Motivated by reconciling call-by-name (CBN) and call-by-value (CBV), CBPV has shown great potential for expressing computations by explicitly separating values and computations under the slogan "a value is, a computation does". As a side product, CBPV ended up developing powerful semantics for expressing evaluation order and side effects.

The goal of the Zydeco project is to further experiment with the potential of call-by-push-value. Specifically, the project aims to encode the status of the stack into the type system. The significance of codatatype - the dual of the algebraic datatype - is recognized and utilized as a good fit for manipulating the stack by explicitly doing pattern matching on the stack. By leveraging the stack semantics, Zydeco aims to be a functional programming language that is easy for the programmer to reason about the stack and operate on it directly.

\section{Encoding Calling Conventions In Types}

It would be nice if the programmer can just tell from the type signature whether the computation is going to be eagerly evaluated or lazy evaluated. Consider the type of a regex matcher: Rule -> String -> Bool. From the user's perspective, we may wonder what's the exact behavior of the matcher - is it supposed to be a ``compiler'' that takes the rule and turns it into a state machine with fast checking speed, or merely a curried version of an ``interpreter'' that inspects the rule on the fly? Staring at the type, there is no hint of how the function is supposed to be used: is it useful to pass in a rule and cache it for later use or not?

\begin{listing}[ht]
    \begin{multicols}{3}
        \inputminted{Haskell}{examples/mappre1.zydeco}
        \vfill
        \inputminted{Haskell}{examples/mappre2.zydeco}
        \vfill
    \end{multicols}
    \begin{multicols}{2}
        \inputminted{Haskell}{examples/map1.zydeco}
        \vfill
        \inputminted{Haskell}{examples/map2.zydeco}
        \vfill
    \end{multicols}
    \captionof{listing}{The comparison between an eager and a lazy version of map}
    \label{code: map}
\end{listing}

A type system that adopts call-by-push-value can ease such confusion. All types are classified by two categories: \textit{Value $\mathcal{A}$} and \textit{Computation $\mathcal{B}$}. All computations are done on objects $b$ of sort $\mathcal{B}$, while all objects $a$ of sort $\mathcal{A}$ are delivered as is. To defer or freeze a computation $b$, one can wrap it in a \textit{thunk}, denoted by $\{ b \}$, which is an instance of sort $\mathcal{A}$. To return a value as is, one can use \textit{return}, denoted by $\texttt{ret}~a$. To unwrap a thunk and continue the calculation, one can use the \textit{force} operator, denoted by $!~a$. And finally, to complete computation and bind the returned result to a variable, one can use the \textit{do} structure, denoted by $\texttt{do}~x \leftarrow b_1;~b_2$. The key observation here is that by introducing thunks and ways of manipulating thunks, the programmer gains much better control over computation.

Adding thunks significantly changes our type system by bringing in $U$ types - thunk types, and $F$ types - returner types. Just as the name indicates, a thunk-captured computation will have $U B$ types, while return values will have $F A$ types. The type system is now presented as:

\[\begin{array}{rcl}
    \TAMV & \Coloneqq & \TAThunk{\TBMV} \mid \textsf{data} \mid \dots \\
    \TBMV & \Coloneqq & \TBReturn{\TAMV} \mid \textsf{codata} \mid \TBArrow{\TAMV}{\TBMV} \mid \dots \\
\end{array}\]
% \captionof{figure}{Types of Zydeco}

As an illuminating example, Listing \ref{code: map}. demonstrates two versions of $\texttt{map}$ functions: the first one demands both $\texttt{f}$ and the list passed in to start computing, while the second one is curried and can return a concrete mapper that can be cached and applied later. Note that the types now indicate the computational properties of the function.

\section{Functions as Computations; Functions are Codatatypes}

A subtle question may have arisen from the type system described above: why is the arrow type listed as a computation type instead of a value type? Indeed, functions are treated as values in most languages because functions don't step. For example, in CBV languages it's a common technique to wrap a term with a function that takes a unit to achieve the effect of a thunk. Nevertheless, it's not the case in CBPV. In CBPV, arguments are pushed onto the stack and when the function is evaluated, it takes arguments from the top of the stack, which is exactly where Call-By-Push-Value gets its name. Since the functions do step in CBPV, we should treat them as computations. The ``function'' in CBV  is now just a ``thunk'' in CBPV.

Moreover, we can see that function is codatatype. Codatatype is a generalization of function, which does a pattern matching on the stack top. We can see how the function type is encoded as codatatype in Listing \ref{code: codata}.

\begin{listing}[ht]
    \begin{multicols}{2}
        \inputminted{Haskell}{examples/fn_as_codata.zydeco}
        \vfill
        \inputminted{Haskell}{examples/fn_multi.zydeco}
        \vfill
    \end{multicols}
    \captionof{listing}{Functions are codatatypes}
    \label{code: codata}
\end{listing}

To write a function is just removing the argument from the stack top and doing the computation. Here \texttt{.arg} is called a destructor. To call a function is just pushing the argument onto the stack top. For a variadic function, two destructors are needed: one to push more arguments to the stack, and the other to conclude the function call. A \texttt{comatch} structure will pop the stack and see whether it's \texttt{.more} or \texttt{.done}.

The roles of the ``function'' type in the CBV sense are now separated into thunk and codatatype. Thunk is responsible for suspending the computation, and codatatype is responsible for stack manipulation. The function type in CBPV is just a syntax sugar for codatatype.

\section{Manipulating Stack With Codatatype}

Codatatype plays a key role in characterizing computations. Codatatype is the dual of datatype. Same as the function type, it is a negative type where its introduction form pops from the stack and its elimination form pushes to the stack.
% \begin{listing}[h]
%     \inputminted{Haskell}{examples/abort.zydeco}
%     \captionof{listing}{Function as codatatype}
%     \label{code: abort}
% \end{listing}
\begin{listing}[ht]
    \begin{multicols}{2}
        \inputminted{Haskell}{examples/sumfn.zydeco}
        \vfill
        \inputminted{Haskell}{examples/sumco.zydeco}
        \vfill
    \end{multicols}
    \captionof{listing}{Comparing a tail-recursive sum function with a sum implemented in \texttt{comatch}}
    \label{code: sum}
\end{listing}

Listing \ref{code: sum} shows a tail-recursive sum function that uses datatype to encode a linked list and a sum implemented in \texttt{comatch}, the introduction form of codatatype, that uses the stack directly. The main difference between the two approaches is that by explicitly pattern matching on the stack, the \texttt{comatch} version is more concise and direct. All states are maintained on the stack and the traceback is transparent to the user.

% \section{Compilation}
\section{Previous Work on Call-By-Push-Value}

\textit{Call-By-Push-Value}, introduced by Paul Blain Levy, is the pioneer of this programming paradigm that most research on call-by-push-value is based on. \textit{Probabilistic call by push value} introduce a probabilistic extension of Levy's Call-By-Push-Value, which is an example extension of call-by-push-value. In his thesis \textit{Gradual Type Theory}, Max S. New et al. utilized call-by-push-value to give an axiomatic account of both call-by-value and call-by-name gradual languages.

\section{Current Status and Future Goals}

Currently, the project is still at an early stage. By far our implementation covers the parser and a small type checker supporting monomorphic datatype and codatatype, and a CEK-machine style evaluator.

The ultimate goal is to make Zydeco a research language for CBPV as well as an ideal intermediate representation and compilation target. The well-defined operational semantics makes CBPV an ideal target for embedding both CBV and CBN programs, even effectful programs. We also plan to explore the possibility of extending the language with more features. On the front-end side, adding parametric polymorphism (à la System $F$) and type constructors (à la System $F_\omega$) would be natural extensions. As for compilation, it might be interesting to perform optimization passes on CPBV and see how much effort can be saved by changing the calling convention, which potentially becomes friendlier to the compiler.

\end{document}
